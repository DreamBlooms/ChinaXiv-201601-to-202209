[
    {
        "type": "text",
        "text": "一种基于元胞自动机的动态回濒搜索优化算法",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "杨军，张达敏，潘志远，刘冬，陈娟敏(贵州大学 大数据与信息工程学院，贵阳 550025)",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "摘要：针对传统回溯搜索优化算法存在收敛速度慢、搜索精度不高等问题，提出了一种基于元胞自动机和正交实验设计的改进算法。首先将正交实验设计方法引入算法的交叉算子中，得出具有代表性的优质子代个体；然后在元胞自动机邻居模型的基础上，对个体展开领域内多父代正交交叉操作，提高算法的开采能力和搜索效率；最后对参与交叉的种群引入动态优秀个体比例权重进行选择更新，并采用新的动态变异方程，平衡算法的全局搜索和局部搜索能力。通过对12个标准测试函数进行仿真实验，并与其他6种表现良好的算法进行比较，结果表明，改进的算法在收敛速度以及寻优精度方面都具有明显优势。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "关键词：回溯搜索优化算法；元胞自动机；正交实验设计；多父代正交交叉；动态变异方程 中图分类号：TP301.6 doi: 10.19734/j.issn.1001-3695.2018.07.0520 ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Dynamic backtracking search optimization algorithm based on cellular automata ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Yang Jun, Zhang Damin†,Pan Zhiyuan,Liu Dong, Chen Juanmin (College of Big Data & Information Engineering Guizhou University,Guiyang 55o025,China) ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Abstract:According to the slowconvergence speed and low searching precisionof traditional backtracking search optimizationalgorithm，thispaperproposedanimprovedalgorithm basedoncelularautomatonand orthogonal experimentaldesign.Firstly,thealgorithmintroducedorthogonal experimentaldesignmethodintothecrossveroperatorto obtain representative high-qualityofspring individuals；Then based on the neighbor model of celular automaton,the method caried out the orthogonal crossver operation of multiple parents in thedomain for individuals，which was beneficialto improve the miningcapacityandsearch eficiencyof thealgorithm;Finally,inorder tobalance theglobal searching and local searchingabilityof thealgorithm,the method introduced thedynamic proportional weightofexcellent individuals into thecross-population to select and update them，with adopted anewdynamic variation equation.The simulation experiments selected12 standard testfunctionsand compared with 6other wel-behavedalgorithms,theresults show that the improved algorithm has obvious advantages in convergence speed and optimization accuracy. ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Keywords:backtracking search optimizationalgorithm;celularautomaton;orthogonal experimental design；multiple parent orthogonal crossover; dynamic variation equation ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "0 引言",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "智能优化算法是受人类智能、生物群体社会性或自然现象规律的启发而提出的随机搜索算法。因其自身的高效性、通用性和易操作性等特点，近年来在生产调度、图像处理、数据挖掘等众多工程领域得到了广泛的应用。目前常用的智能优化算法主要有遗传算法[1]（genetic algorithm，GA）、粒子群算法[2]（particle swarm optimization，PSO）、差分进化算法[3]（differential evolutionary，DE）、人工蜂群算法[4]（artificialbeecolony，ABC）等，以及一些相应的改进算法。例如，Liang等人[5]提出的粒子群改进算法CLPSO，夏学文等人[6]改进的RLPSO；Wang 等人[7提出的OXDE，周晓根等人[8]提出的DELLU；以及Gao等人[基于蜂群算法改进的MABC，周新宇等人[10]改进的ABC-OED等。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "回溯搜索优化算法[]（backtracking search algorithm,BSA）是Civicioglu在2013年提出的一种新型启发式优化算法。该算法由于结构框架简单，控制参数较少和独特的记忆功能用于引导搜索，因而具有较强的全局搜索能力，在求解复杂的约束优化问题中发挥了重要作用。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "但是，由于BSA算法变异算子中的历史种群引导学习，以及交叉算子中两种交叉策略随机调用都具有一定的盲目性。使得算法拥有较好的探索能力，但开发能力较为欠缺，在求解多峰值问题时算法的局部搜索能力较弱并且容易早熟收敛[12-14]。针对这一问题，本文提出一种基于元胞自动机的动态回濒搜索优化算法（dynamicbacktrackingsearchoptimizationalgorithmbasedoncellularautomata ，CA-DBSA)，分别从交叉算子和变异算子入手，在交叉算子中引入了正交实验设计（orthogonal experimental design,OED）方法，并在元胞自动机（cellularautomaton，CA）的邻居模型基础上进行并行式多父代正交交叉，较大程度上提高了算法的搜索效率。同时，为了平衡算法的探索与开发能力，在参与交叉的个体选取与变异方程的引导学习环节中分别引入动态自适应调节策略。最后通过对标准测试函数的测试与比较，实验结果表明，改进的算法具有较快的收敛速度",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "与以及较高的寻优精度。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "1 回溯搜索优化算法",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "回溯搜索优化算法是一种基于种群迭代的智能进化算法，与一般的进化算法相似，都具有三个基本的基因算子，即交叉、变异和选择。具体包括五个步骤，分别为种群初始化、选择I、种群变异、种群交叉、选择 $\\mathrm { I I }$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "1）种群初始化",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "BSA的种群初始化以随机产生的方式进行，且包括种群Pop 和历史种群oldPop的同时初始化。即：",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\n\\left\\{ \\begin{array} { c } { P o p _ { i , j } \\sim U ( l o w _ { j } , u p _ { j } ) } \\\\ { o l d P o p _ { i , j } \\sim U ( l o w _ { j } , u p _ { j } ) } \\end{array} \\right.\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "其中， $i \\in \\{ 1 , 2 , . . . , S N \\}$ ， $j \\in \\{ 1 , 2 , . . . , D \\}$ ； $\\mathit { s N }$ 和 $D$ 分别为种群的规模和维数； $l o w$ 和 $u p$ 分别指搜索空间的下界和上界； $U$ 为随机均匀分布函数。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2）选择I ",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "BSA的选择I策略主要用于确定历史种群oldPop的更新。如式（2）和（3）所示。",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\no l d P o p = \\left\\{ \\begin{array} { l l } { { P o p } } & { { i f ~ a < b } } \\\\ { { o l d P o p } } & { { o t h e r w i s e } } \\end{array} \\right.\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\no l d P o p = r a n d p e r m ( o l d P o p )\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "其中： $\\mathbf { \\Delta } _ { a }$ 和 $b$ 均为服从区间（0,1）上的均匀分布随机数；randperm为重新排序函数。在每次迭代过程中，历史种群的个体都有机会取到当代以及之前任意一代的值，凭借其独特的记忆功能引导种群的后续进化。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "3）种群变异 ",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "BSA的变异过程如式（4）所示。",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nM u t a n t = P o p + F \\bullet ( o l d P o p - P o p )\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "其中：Mutant为生成的变异种群； $F$ 为变异尺度系数，用于控制引导搜索向量 $( o l d P o p - P o p )$ 的幅度， $F = 3 \\bullet r a n d n$ ，randn为服从标准正态分布的随机数。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "4）种群交叉 ",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "BSA的交叉过程包含两种交叉方式，每个个体通过对两种方式的随机调用，生成0-1映射矩阵 $m a p$ ，初始map 为一全1矩阵。具体生成公式如式（5）（6）所示：",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nm a p _ { i , u ( 1 : \\lceil m i x r a t e \\bullet r a n d \\bullet D \\rceil ) } = 0\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nm a p _ { i , r a n d i ( D ) } = 0\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "其中： $u = r a n d p e r m ( D )$ ，「]表示向上取整，mixrate为设置的交叉概率，rand为生成一个[0,1]区间的随机数；randi $( D )$ 为生成一个 $[ 1 , D ]$ 区间的随机整数。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "再由确定的map 映射矩阵，实现种群Pop和变异种群Mutant之间的对应交叉，最终产生新的实验种群 $T$ 。如式（7）所示。",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nT _ { i , j } = \\left\\{ { \\begin{array} { c c } { P o p _ { i , j } } & { m a p _ { i , j } = 0 } \\\\ { M u t a n t _ { i , j } } & { m a p _ { i , j } = 1 } \\end{array} } \\right.\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "5）选择II ",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "BSA的选择ⅡI策略采用了贪婪选择机制，在新生成的实验种群 $T$ 和种群Pop之间选择对应位置上的最优（适应度值较小的）个体用于下一轮进化。如式（8）所示。",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nP o p _ { i } = \\left\\{ \\begin{array} { c c } { { T _ { i } } } & { { i f \\ f i t n e s s \\left( T _ { i } \\right) < f i t n e s s \\left( P o p _ { i } \\right) } } \\\\ { { P o p _ { i } } } & { { o t h e r w i s e } } \\end{array} \\right.\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "重复以上步骤，直至满足循环终止条件，最后输出最优解。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2 元胞自动机与正交实验设计",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2.1 元胞自动机",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "元胞自动机[15\\~17]（CA）是由 Neumann 首先提出的一种经典的自然计算模型，具有模拟复杂系统时空演化过程的能力。CA共由元胞、状态、邻居和规则四部分组成，是一种时间、空间和状态都具有离散性的动力学系统。所有的元胞构成一个元胞空间，元胞空间中的每个元胞将并行同步演变；元胞在某一时刻只能存在一种状态，且该状态来源于固定的有限离散状态集；邻居是元胞个体周围按一定几何规则划分的元胞集合，每个元胞的下一时刻状态由该元胞以及与其对应的邻居共同决定；规则是根据元胞当前状态及其邻居状态确定下一时刻该元胞状态的动力学函数。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "二维元胞自动机的邻居模型划分通常可分为四种：冯-诺依曼型，摩尔型，扩展的摩尔型，马哥勒斯型。其中最常用的是冯-诺依曼（VonNeumann）型和摩尔（Moore）型，以常用规则四方网格划分为例，如图1所示。",
        "page_idx": 1
    },
    {
        "type": "image",
        "img_path": "images/76d7a1c8c9dbfde2d624071bec4faf0c16e1272b6c2df49a67133ebe96014ff9.jpg",
        "img_caption": [
            "图1常用元胞自动机邻居模型",
            "Fig.1Common cellular automaton neighbor models ",
            "图2二维元胞空间拓扑结构",
            "Fig.22-dimensional cellular spatial topology "
        ],
        "img_footnote": [],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "由于元胞空间理论上在各维上无限延伸。因此，对于二维元胞空间需定义周期型边界条件，即上下相接，左右相接，形成一个拓扑的圆环面。如图2所示。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "中3.13.23.33.4(3.5）（4,1） （4.2)（4.3)（4.4) 4,5）(5.1)(5.2）(5.3）（5.4)(5.5）",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2.2 正交实验设计",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "正交实验设计[17-19]（OED）是一种利用正交表来解决多因素、多水平实验的有效方法。在给定的实验范围内，通过正交性准则选取合适的正交表 $L _ { \\scriptscriptstyle M } \\left( Q ^ { \\scriptscriptstyle N } \\right)$ ，来安排较少的实验找出最优的水平组合方式。 $L _ { \\scriptscriptstyle M } \\left( Q ^ { \\scriptscriptstyle N } \\right)$ 表示 $N$ 因素， $\\boldsymbol { \\mathscr { Q } }$ 水平的正交表， $M$ 表示需要安排的实验次数。当 $N$ 和 $\\varrho$ 较大时，执行全面实验的次数为 $Q ^ { \\scriptscriptstyle N }$ ，而OED方法只需从 $Q ^ { \\scriptscriptstyle N }$ 次全面实验中挑选出 $M$ 个均匀分散且具有代表性的点进行实验（ $\\mathbf { \\Omega } _ { M }$ 通常远小于 $\\boldsymbol { Q } ^ { \\scriptscriptstyle N }$ )，较大程度的提高了工作效率。其中， $M = Q ^ { J }$ ， $\\varrho$ 为素数， $J$ 为满足式（9）的正整数。",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nN \\leq \\frac { Q ^ { \\prime } - 1 } { Q - 1 }\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "例如一个四因素，三水平的实验，可以通过正交表 $L _ { 9 } \\left( 3 ^ { 4 } \\right)$ 来执行，如式（10)。但若进行全面实验则需81（34）次。",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nL _ { 9 } \\left( 3 ^ { 4 } \\right) = { \\left[ \\begin{array} { l l l l } { 1 } & { 1 } & { 1 } & { 1 } \\\\ { 1 } & { 2 } & { 2 } & { 2 } \\\\ { 1 } & { 3 } & { 3 } & { 3 } \\\\ { 2 } & { 1 } & { 2 } & { 3 } \\\\ { 2 } & { 2 } & { 3 } & { 1 } \\\\ { 2 } & { 3 } & { 1 } & { 2 } \\\\ { 3 } & { 1 } & { 3 } & { 2 } \\\\ { 3 } & { 2 } & { 1 } & { 3 } \\\\ { 3 } & { 3 } & { 2 } & { 1 } \\end{array} \\right] }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "3 改进的BSA ",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "3.1基于元胞自动机的多父代正交交叉算子",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "基本回溯搜索算法采用的交叉方式是常用的二项式交叉，而二项式交叉算子随机产生子代个体，并不能实现对相应搜索空间的充分开采。多父代正交交叉算子[18-20]利用正交实验设计的方法，对多个父代进行因素和水平的划分，并采用正交表产生一系列具有代表性的组合来生成子代个体，从而在确定的样本空间中完成高效搜索。本文结合元胞自动机模型，提出一种基于元胞自动机的多父代正交交叉算子。该算子建立在VonNeumann型元胞邻居基础上，每个个体与周围的四邻居共同组成多父代参与正交交叉，最后选出子代中最优的水平组合个体作为该元胞的下一时刻状态。由于元胞自动机的并行演变策略和正交交叉的高效搜索性能，使得该新型交叉算子在寻优速度和精度上都具有较大的提升。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "同时，为了避免算法后期陷入局部最优而早熟收敛的可能性，在交叉算子中引入了随机扰动策略。当元胞个体满足交叉概率时执行多父代正交交叉；反之，则对该个体随机挑选任意维以初始化的方式进行扰动。进一步增强了种群的多样性。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "算子操作具体描述如下：",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "a）判断元胞个体是否满足交叉概率mixrate。如果rand $<$ mixrate成立则跳转至b)，执行多父代正交交叉。否则对该个体进行随机扰动：",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nd i m = c e i l \\left( r a n d \\cdot D \\right)\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nx _ { i , j } = \\left\\{ \\begin{array} { c c } { { l o w _ { j } + \\left( u p _ { j } - l o w _ { j } \\right) \\bullet r a n d } } & { { i f \\ j \\in r a n d p e r m ( D , d i m ) } } \\\\ { { x _ { i , j } } } & { { o t h e r w i s e } } \\end{array} \\right.\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "b)将参与交叉的 $\\varrho$ 个父代个体分别作为正交实验设计的一个水平，记第 $i$ 个水平为 $\\beta _ { i }$ ， $i \\in \\left\\{ 1 , 2 , . . . , Q \\right\\}$ ，则 $\\beta _ { i } = x _ { i }$ ，$X _ { i } \\in \\left\\{ { x _ { 1 } , x _ { 2 } , . . . , x _ { Q } } \\right\\}$ 。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "c）当优化问题的维度较小时，可直接将因素与维度进行匹配；但是通常在复杂的高维约束优化问题中，因素的选取则需对维度进行切片划分，从而降低OED的工作量。假定将参与交叉的任一个体 $x _ { i }$ 分成 $E { \\big ( } E = N { \\big ) }$ 个片段，每个片段即对应一个因素，如式（13）所示。",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { r l } & { \\left[ \\boldsymbol { G } _ { 1 } = \\left( x _ { 1 } , . . . , x _ { k _ { 1 } } \\right) \\right. } \\\\ & { \\left. \\begin{array} { l } { G _ { 2 } = \\left( x _ { k _ { 1 } + 1 } , . . . , x _ { k _ { 2 } } \\right) } \\\\ { \\ldots } \\\\ { G _ { E } = \\left( x _ { k _ { E - 1 } + 1 } , . . . , x _ { D } \\right) } \\end{array} \\right. } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中： $k _ { 1 } , k _ { 2 } , . . . , k _ { E - 1 }$ 为 $( 1 , D )$ 之间随机生成的正整数，且满足$1 < k _ { 1 } < k _ { 2 } < . . . < k _ { { \\scriptscriptstyle E } - 1 } < D$ 。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "d)令 $k _ { \\mathrm { 0 } } = 0$ ， $k _ { \\scriptscriptstyle E } = N$ ,因此第 $\\textit { j } \\left( { j = 1 , 2 , . . . , N } \\right)$ 个因素的 $\\varrho$ 个水平可以表示为",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\left\\{ \\begin{array} { l l } { G _ { j } \\left( 1 \\right) = \\left( \\beta _ { 1 , k _ { j - 1 } + 1 } , \\beta _ { 1 , k _ { j - 1 } + 2 } , . . . , \\beta _ { 1 , k _ { j } } \\right) } \\\\ { G _ { j } \\left( 2 \\right) = \\left( \\beta _ { 2 , k _ { j - 1 } + 1 } , \\beta _ { 2 , k _ { j - 1 } + 2 } , . . . , \\beta _ { 2 , k _ { j } } \\right) } \\\\ { \\dots } \\\\ { G _ { j } \\left( Q \\right) = \\left( \\beta _ { Q , k _ { j - 1 } + 1 } , \\beta _ { Q , k _ { j - 1 } + 2 } , . . . , \\beta _ { Q , k _ { j } } \\right) } \\end{array} \\right.\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "e)构造正交表 $L _ { \\boldsymbol { M } } \\left( \\boldsymbol { Q } ^ { \\boldsymbol { N } } \\right) = \\left[ a _ { i , j } \\right] _ { \\boldsymbol { M } \\times \\boldsymbol { N } }$ ，根据正交表 $L _ { \\scriptscriptstyle M } \\left( Q ^ { \\scriptscriptstyle N } \\right)$ 安排 实验，产生 $M$ 个子代个体（ $M$ 组实验): ",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { r l } & { \\{ \\vphantom { \\int } { \\int } ( G _ { 1 } ( a _ { _ { 1 , 1 } } ) , G _ { 2 } ( a _ { _ { 1 , 2 } } ) , . . . , G _ { N } ( a _ { _ { 1 , N } } ) )  } \\\\ & {  \\{ \\vphantom { \\int } { \\sum } { G } _ { 1 } ( a _ { _ { 2 , 1 } } ) , G _ { 2 } ( a _ { _ { 2 , 2 } } ) , . . . , G _ { N } ( a _ { _ { 2 , N } } ) )  } \\\\ & {  \\vphantom { \\int } { G }  } \\\\ & {  ( { G } _ { 1 } ( a _ { _ { M , 1 } } ) , G _ { 2 } ( a _ { _ { M , 2 } } ) , . . . , G _ { N } ( a _ { _ { M , N } } ) ) } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "f）采用式（16）计算分析每种因素的每个水平对实验结果的影响，从而得出最优的水平组合方式。",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nS _ { n q } = \\frac { \\displaystyle \\sum _ { m = 1 } ^ { M } { F _ { m } \\times z _ { m n q } } } { \\displaystyle \\sum _ { m = 1 } ^ { M } z _ { m n q } }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中： $F _ { _ m }$ 为第 $\\mathfrak { m } ( m { = } 1 , 2 , . . . , M )$ 组实验的结果， $S _ { n q }$ 为因素$n ( n { = } 1 , 2 , { \\ldots } , N )$ 的第 $\\scriptstyle q ( q = 1 , 2 , \\ldots , Q )$ 个水平对结果的影响程度。$z _ { m n q }$ 表示第 $m$ 组实验中是否包含因素 $n$ 的第 $\\boldsymbol { q }$ 个水平，若包含则 $z _ { m n q } = 1$ ，否则 $z _ { m n q } = 0$ 。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "3.2交叉选择机制",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "BSA算法的交叉环节中，通过map 映射矩阵完成对变异种群Mutant和种群Pop的随机交叉操作。虽然已将原始交叉替换为基于元胞自动机的多父代正交交叉算子，较好地提高了算法的搜索效率和精度，但在搜索方向上仍然存在一定的盲目性。为此，受遗传算法交叉前进行一定概率的择优选取启发[1]，本文引入交叉选择机制，并提出一种动态优秀个体比例权重 $p \\%$ 。用于对参与交叉的个体进行选择，在算法执行的不同阶段以合适的搜索方向引导交叉。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "当种群变异结束后，变异种群Mutant和种群 $P o p$ 将作为候选交叉成员。从候选成员中选取适应度值最优的前 $S N { \\bullet } p \\%$ 个个体，再从剩下的成员中随机选取 $S N { \\bullet } ( 1 - p \\% )$ 个个体共同组成交叉群体。优秀个体比例权重 $p \\%$ 满足如下公式：",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\np = p _ { \\mathrm { m i n } } + \\left( p _ { \\mathrm { m a x } } - p _ { \\mathrm { m i n } } \\right) \\bullet \\left( { \\frac { e p k } { e p o c h } } \\right) ^ { 2 }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中: $p _ { \\operatorname* { m i n } }$ 和 $p _ { \\operatorname* { m a x } }$ 分别为权重的最小值和最大值；epk 和epoch分别为算法的当前迭代次数和迭代总次数。由式（17）可以看出，随着进化代数的不断增加，优秀个体比例权重 $p \\%$ 越来越大。使得算法在执行前期交叉算子偏向于全局搜索，而到了中后期时则偏向于在全局最优值附近进行精确的局部搜索。在搜索方向上起到了较好的引导作用。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "3.3 动态变异方程",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "通过对BSA算法的变异算子分析可知，该算法的变异操作能记忆之前迭代过的种群，并以迭代过的历史种群作为经验来指导当前种群的搜索方向，使之具有较强的全局搜索能力。但因其仅仅通过设置历史种群对搜索方向进行引导，个体进化缺乏一定的学习能力，导致算法的收敛速度减慢，局部开采能力也较弱。针对这一缺点，在文献[5,13]提出的广泛学习策略以及ABC算法雇佣蜂搜索方程[4.9]的基础上，本文在BSA的变异过程中同时加入最优个体和较优群体的引导，提出一种带有加权因子的自适应动态变异方程。公式如式（18）（19）所示。",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { c } { { M u t a n t } _ { i } = u \\big ( P o p _ { i } + F { \\bullet } \\big ( o l d P o p _ { r _ { 1 } } - P o p _ { r _ { 2 } } \\big ) \\big ) + } \\\\ { ( 1 - u ) \\big ( P o p _ { b e s t } + F { \\bullet } \\big ( o l d P o p _ { g r _ { - } b e s t } - P o p _ { i } \\big ) \\big ) } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nu = \\exp \\left( - \\sqrt { e p k - 1 } \\right)\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "其中： $\\boldsymbol { u }$ 为加权因子， $i , r _ { 1 } , r _ { 2 }$ 为 $[ 1 , S N ]$ 上互不相等的随机整数;$P o p _ { b e s t }$ 为当前种群搜索到的全局最优个体， $o l d P o p _ { g r \\_ b e s t }$ 为当代历史种群中前 $t \\left( \\mathrm { m o d } \\left( S N , t \\right) = 0 \\right)$ 个优秀个体组成的较优群体。选出的种群 $o l d P o p _ { g r \\_ b e s t }$ 和种群oldPop 规模相同，具体操作如下：将oldPop中选出的前 $\\textit { t }$ 个优秀个体复制成 $S N / t$ 组，并对每一组随机排序，最后重新组合成种群 $o l d P o p _ { g r \\_ b e s t }$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "式（18）的前半部分通过选取种群oldPop和 $P o p$ 中与变异个体 $i$ 不同的个体组成差分向量来增强算子的勘探能力，后半部分通过全局最优个体 $P o p _ { b e s t }$ 和较优历史群体$o l d P o p _ { g r \\_ b e s t }$ 来增强算子的精英学习能力和开采能力。并且利用式（19）[21]在算法执行的不同阶段对全局搜索和局部搜索能力进行合适的加权。使得算法执行前期以全局搜索为主，而后期则以局部开发为主。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "3.4改进算法流程",
        "text_level": 1,
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "改进后的CA-DBSA算法具体实现流程如下：",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "a)初始化种群Pop、历史种群oldPop以及种群规模SN、交叉概率mixrate和最大进化代数epoch等参数，设置当前进化代数 $e p k = 1$ 0",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "b)执行选择I策略：更新历史种群oldPop。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "c)评价种群Pop和历史种群oldPop的适应度值，选出最优个体 $P o p _ { b e s t }$ 和较优历史群体 $o l d P o p _ { g r \\_ b e s t }$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "d)执行变异操作：根据式（18）（19）计算出加权因子 $\\boldsymbol { u }$ 和变异种群Mutant。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "e)执行交叉选择机制：根据式（17）计算出当代优秀个体比例权重 $p \\%$ ，并从种群 $P o p$ 和变异种群Mutant中完成对参",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "与交叉个体的选择。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "f)将选出的参与交叉群体随机分布在规模为$\\boldsymbol { a } \\times \\boldsymbol { a } \\left( \\boldsymbol { a } \\times \\boldsymbol { a } = \\boldsymbol { S } \\boldsymbol { N } \\right)$ 的二维网格元胞空间中。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "g)执行交叉操作：以交叉概率mixrate对元胞空间中的每个元胞个体进行判断。如果满足则以VonNeumann型元胞邻居结构为基础，构造正交表 $L _ { \\scriptscriptstyle M } \\left( Q ^ { \\scriptscriptstyle N } \\right)$ 执行多父代正交交叉，并获得最优组合形式的子代。否则以式（11）（12）对个体进行随机扰动。最终得出实验种群 $T$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "h)执行选择ⅡI策略：评价实验种群 $T$ ，选出用于下一轮进化的优秀种群Pop。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "i)找出第epk代的最优个体和最优适应度值。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "j)判断是否达到循环终止条件。若是则转步骤k)，否则$e p k = e p k + 1$ ，跳转至步骤b)。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "k)输出当前的最优个体和最优适应度值。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "4 数值实验及结果分析",
        "text_level": 1,
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "为了验证本文算法的可行性与效果，选取12个标准测试函数[68]对其进行数值实验。同时与基本BSA 算法[1I]、参考文献中的CLPSO[5]、MABC[9]和LBSA[14]算法，以及利用正交交叉策略改进的OXDE7和多父代交叉算子的MPCO-ABC[20]算法进行性能比较。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "测试函数如表1所示。表中给出了函数具体名称和表达式、搜索空间范围以及最优值。其中 $f _ { 1 } \\sim f _ { 5 }$ 是单峰类型函数，侧重于衡量算法的收敛速度和精度； $f _ { 6 } \\sim f _ { 1 2 }$ 是多峰类型函数，侧重于衡量算法的全局搜索能力。",
        "page_idx": 3
    },
    {
        "type": "table",
        "img_path": "images/5bec7cc05cc9c03e40713a60a628f08c1f1fbd2707d1ac1e24bda983832f9a72.jpg",
        "table_caption": [
            "表112个标准测试函数",
            "Table 112 standard test functions "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td>Table1 函数名</td><td>12standard Tunctions 函数表达式</td><td>搜索空间</td><td>最优值</td></tr><tr><td>Sphere</td><td>f（x）=∑x² i=1</td><td>[-100,100]</td><td>0</td></tr><tr><td>Tablet</td><td>f（x）=10°x²+∑x²</td><td>[-100,100]</td><td>0</td></tr><tr><td>Rosenbrock</td><td>fs（x）)=∑(100（x-x²）²+(1-x））</td><td>[-30,30]</td><td>0</td></tr><tr><td>Schwefel 1.2</td><td>1（x）=（）²</td><td>[-100,100]</td><td>0</td></tr><tr><td>Schwefel 2.22</td><td>fs(x）=∑x1+[[x</td><td>[-10,10]</td><td>0</td></tr><tr><td>Ackley</td><td>f（x20+e-20</td><td>[-32,32]</td><td>0</td></tr><tr><td>Alpine</td><td>f(x)=∑lx sin(x)+0.1x|</td><td>[-10,10]</td><td>0</td></tr><tr><td>Rastrigin</td><td>fs(x)=∑(x²-10cos(2πxi)+10)</td><td>[-5.12,5.12]</td><td>0</td></tr><tr><td>Griewank</td><td>cos + 台4000 f（x）=∑</td><td>[-600,600]</td><td>0</td></tr><tr><td>Schwefel 2.26</td><td>f(x)=418.98288727216249D-∑（(x sin(x)) i=1</td><td>[-500,500]</td><td>0</td></tr><tr><td>Levy and Montalvo 1</td><td>fn(x)=(10sin(πy)+∑(y-1)(1+10sin(+1)+ (yn-1)²),y =1+0.25(x +1)</td><td>[-10,10]</td><td>0</td></tr><tr><td>Levy and Montalvo 2</td><td>f2(x)=0.1(sin(3x)+∑(x-1)²(1n())+ ( −1)²(1+sin²(2𝜋 x)))</td><td>[-5,5]</td><td>0</td></tr></table></body></html>",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "本次实验中，7种对比算法的种群规模SN 和最大进化代数epoch均设置为25和5000；基本BSA算法的交叉概率mixrate 设为1；CA-DBSA中优秀个体比例权重 $p _ { \\operatorname* { m i n } }$ 、 $p _ { \\operatorname* { m a x } }$ 分别为10、90；正交表采用六因素五水平的 $L _ { 2 5 } \\left( 5 ^ { 6 } \\right)$ 。其他算法的参数设置方法按照文献[5,7,9,14,20]进行对应设置。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "实验分为三组进行，第1、2组实验中，测试函数的维数$D$ 均取30；第3组实验中 $D$ 均取60。针对同一测试函数的仿真实验，每种算法独立运行30次，记录其寻得最优值的平均值（Mean）和标准差（Std.Dev）。为了进一步分析比较 7种算法之间的性能差异，在第2、3组实验中引入显著性水平$\\alpha = 0 . 0 5$ 的Wilcoxon秩和检验方法对其结果进行直观呈现。+、、 $\\approx$ 分别表示其他算法的性能要优于、劣于、相当于CA-DBSA算法。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "为了证明本文所提算法CA-DBSA交叉概率mixrate的最理想取值，在第一组实验中，对mixrate分别取0.5\\~0.9的5个不同的值进行测试。结果如表2所示，其中每个函数的最优测试结果已对其进行加粗体现。从最优实验结果的分布情况来看，当交叉概率mixrate取值为0.7时，CA-DBSA算法的寻优能力在12个测试函数上均表现最好。当交叉概率偏小时，算法开采能力较弱，局部搜索不充分。反之，在偏大时则易陷入局部最优。因此，在接下来的第二和第三组实验中，本文的CA-DBSA算法交叉概率mixrate均取值为0.7。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "表3给出了第2组实验 $D = 3 0$ 时各算法的测试结果。从表中每个函数的最优测试结果可以看出，共有9个函数的最优结果是由CA-DBSA算法实验得到。表明了本文的CA-DBSA算法在大部分测试函数上的实验结果都要优于其他几种算法，表现出了较强的全局搜索和局部搜索能力。相对于改进的CLPSO、MABC和基本BSA来说，CA-DBSA算法在寻优精度和稳定性上均具有明显的优势；MPCO-ABC和LBSA均分别只在一个函数上性能优于CA-DBSA；而对于OXDE，只有在函数 $f _ { 3 }$ 、 $f _ { 6 }$ 和 $f _ { 1 1 }$ 上，OXDE算法的寻优能力比本文算法更优，且 $f _ { 9 }$ 上相当于本文算法。这正也体现出了正交实验设计方法的有效性。",
        "page_idx": 4
    },
    {
        "type": "table",
        "img_path": "images/b7570dbe50b2869c665fa50e0b5e84b6d2d26cc83a37820b9f709941cfc8391d.jpg",
        "table_caption": [
            "Table 2 CA-DBSA algorithm with ${ \\mathrm { D } } { = } 3 0$ experimental results with different values of mixrate "
        ],
        "table_footnote": [
            "表3时7种算法的实验结果"
        ],
        "table_body": "<html><body><table><tr><td rowspan=\"2\">函数</td><td colspan=\"5\">Mean±Std.Dev</td></tr><tr><td>mixrate =0.5</td><td>mixrate =0.6</td><td>mixrate =0.7</td><td>mixrate =0.8</td><td>mixrate=0.9</td></tr><tr><td>f</td><td>2.82E-114±3.41E-114</td><td>7.03E-118±3.75E-117</td><td>3.56E-121±1.38E-120</td><td>2.29E-120±3.42E-119</td><td>1.63E-116±5.97E-117</td></tr><tr><td>f</td><td>1.17E-112±5.26E-110</td><td>1.85E-117±2.44E-116</td><td>1.60E-122±4.73E-122</td><td>3.04E-119±3.26E-119</td><td>6.05E-115±3.09E-116</td></tr><tr><td>f</td><td>7.44E+01±5.52E+01</td><td>5.81E+01±2.47E+01</td><td>1.81E+00±1.56E-01</td><td>2.23E+00±1.07E+00</td><td>3.96E+01±1.20E+01</td></tr><tr><td>f4</td><td>5.41E-158±3.11E-160</td><td>2.63E-165±2.79E-164</td><td>1.47E-174±3.10E-174</td><td>1.83E-171±4.36E-171</td><td>1.47E-164±4.72E-166</td></tr><tr><td>f5</td><td>3.02E-63±1.48E-63</td><td>4.92E-68±1.89E-66</td><td>1.37E-75±8.77E-75</td><td>5.26E-72±7.25E-71</td><td>2.32E-66±6.74E-66</td></tr><tr><td>f</td><td>9.63E-09±9.91E-08</td><td>5.03E-11±4.99E-10</td><td>2.03E-12±4.50E-12</td><td>4.15E-10±3.89E-10</td><td>3.37E-09±4.68E-10</td></tr><tr><td>f</td><td>4.81E-11±6.23E-12</td><td>3.47E-12±1.16E-12</td><td>7.94E-15±1.03E-15</td><td>5.11E-14±1.57E-13</td><td>2.87E-12±4.15E-11</td></tr><tr><td>f</td><td>6.05E-01±4.67E+00</td><td>4.76E-01±2.67E-01</td><td>2.05E-01±3.42E-02</td><td>8.49E-01±6.64E-01</td><td>5.29E+00±1.10E+00</td></tr><tr><td>f</td><td>1.93E-07±2.56E-06</td><td>0.00E+00±0.00E+00</td><td>0.00E+00±0.00E+00</td><td>2.05E-10±1.35E-11</td><td>2.29E-08±4.51E-08</td></tr><tr><td>f10</td><td>5.83E-09±2.26E-10</td><td>1.52E-11±1.47E-11</td><td>1.82E-12±1.13E-13</td><td>9.01E-10±7.23E-11</td><td>7.05E-10±4.43E-10</td></tr><tr><td>f</td><td>2.76E-16±3.71E-16</td><td>4.73E-19±1.05E-20</td><td>1.49E-21±1.75E-22</td><td>1.19E-18±1.32E-18</td><td>3.54E-17±2.16E-16</td></tr><tr><td>f12</td><td>6.87E-24±3.61E-26</td><td>3.13E-27±3.65E-28</td><td>1.13E-31±2.68E-31</td><td>3.24E-29±4.41E-29</td><td>1.17E-25±2.09E-26</td></tr></table></body></html>",
        "page_idx": 4
    },
    {
        "type": "table",
        "img_path": "images/fc52db4afb28ecd3d0975424c803273d39e5a9f57ecaf52b7a82b86fd020c8d2.jpg",
        "table_caption": [
            "表2时ca-dbsa 算法mixrate不同取值的实验结果",
            "Table 3Experimental results of 7 algorithms at ${ \\mathrm { D } } { = } 3 0$ "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td></td><td>函数</td><td>CLPSO</td><td>MABC</td><td>MPCO-ABC</td><td>OXDE</td><td>BSA</td><td>LBSA</td><td>CA-DBSA</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>2.43E+00</td><td>1.42E-17</td><td>3.69E-16</td><td>2.02E-26</td><td>9.36E-20</td><td>5.88E-71</td><td>3.56E-121</td></tr><tr><td>Std.Dev</td><td>1.92E-01</td><td>6.89E-17</td><td>5.68E-15</td><td>1.23E-25</td><td>4.64E-20</td><td>3.32E-68</td><td>1.38E-120</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>5.90E+00</td><td>1.13E-18</td><td>1.58E-16</td><td>2.79E-27</td><td>2.51E-18</td><td>4.45E-73</td><td>1.60E-122</td></tr><tr><td>Std.Dev</td><td>8.46E+00</td><td>4.84E-18</td><td>2.91E-14</td><td>9.11E-26</td><td>2.24E-18</td><td>2.24E-72</td><td>4.73E-122</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>1.24E+02</td><td>2.88E+01</td><td>3.60E-03</td><td>1.11E-02</td><td>2.50E+01</td><td>1.30E-01</td><td>1.81E+00</td></tr><tr><td>Std.Dev</td><td>5.23E+02</td><td>1.27E+00</td><td>8.03E-03</td><td>1.34E-02</td><td>3.21E+01</td><td>2.52E-01</td><td>1.56E-01</td></tr><tr><td rowspan=\"2\">f4</td><td>Mean</td><td>1.09E+04</td><td>6.89E-14</td><td>5.09E+03</td><td>1.58E-48</td><td>4.00E-36</td><td>4.13E-139</td><td>1.47E-174</td></tr><tr><td>Std.Dev</td><td>6.04E+03</td><td>2.37E-15</td><td>3.81E+03</td><td>4.65E-48</td><td>4.73E-35</td><td>5.68E-137</td><td>3.10E-174</td></tr><tr><td rowspan=\"2\">fs</td><td>Mean</td><td>1.79E-01</td><td>2.40E-10</td><td>1.20E-15</td><td>7.75E-15</td><td>3.14E-14</td><td>2.12E-39</td><td>1.37E-75</td></tr><tr><td>Std.Dev</td><td>3.47E-01</td><td>6.22E-11</td><td>7.34E-15</td><td>1.26E-16</td><td>1.52E-12</td><td>1.74E-39</td><td>8.77E-75</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>1.95E-01</td><td>1.35E-03</td><td>3.06E-09</td><td>7.19E-14</td><td>1.65E+00</td><td>1.34E+00</td><td>2.03E-12</td></tr><tr><td>Std.Dev</td><td>1.61E-01</td><td>1.33E-03</td><td>1.26E-10</td><td>5.77E-15</td><td>1.34E+00</td><td>2.86E-01</td><td>4.50E-12</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>5.38E+00</td><td>3.80E-05</td><td>2.69E-08</td><td>3.24E-12</td><td>7.44E-14</td><td>1.92E-12</td><td>7.94E-15</td></tr><tr><td>Std.Dev</td><td>2.18E-01</td><td>2.54E-07</td><td>2.12E-08</td><td>4.65E-13</td><td>1.42E-14</td><td>4.78E-12</td><td>1.03E-15</td></tr><tr><td rowspan=\"2\">fs</td><td>Mean</td><td>3.21E+02</td><td>9.02E+01</td><td>6.29E-01</td><td>9.95E+00</td><td>1.39E+01</td><td>1.03E+01</td><td>2.05E-01</td></tr><tr><td>Std.Dev</td><td>9.16E+01</td><td>1.50E+00</td><td>1.07E+01</td><td>6.03E-01</td><td>2.19E+01</td><td>1.48E+00</td><td>3.42E-02</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>6.75E-01</td><td>4.92E-07</td><td>2.01E-16</td><td>0.00E+00</td><td>1.11E-16</td><td>9.90E-03</td><td>0.00E+00</td></tr><tr><td>Std.Dev</td><td>1.28E-02</td><td>9.16E-08</td><td>4.43E-16</td><td>0.00E+00</td><td>4.47E-16</td><td>6.45E-01</td><td>0.00E+00</td></tr><tr><td>f0</td><td>Mean</td><td>8.02E+01</td><td>4.32E-04</td><td>7.59E-06</td><td>1.18E+02</td><td>1.66E+03</td><td>1.95E+03</td><td>1.82E-12</td></tr></table></body></html>",
        "page_idx": 4
    },
    {
        "type": "table",
        "img_path": "images/036ee0743f855173dadee8ee1c009767e052e407b921ef054ae1ac0ca3b8f05e.jpg",
        "table_caption": [
            "第37卷第2期"
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td></td><td>Std.Dev</td><td>1.52E+01</td><td>4.09E-03</td><td>6.75E-06</td><td>7.11E+02</td><td>1.05E+03</td><td>2.29E+01</td><td>1.13E-13</td></tr><tr><td rowspan=\"4\">f1</td><td>Mean</td><td>1.04E+01</td><td>4.95E-01</td><td>2.36E-07</td><td>8.15E-28</td><td>5.70E-02</td><td>1.52E-01</td><td>1.49E-21</td></tr><tr><td>Std.Dev</td><td>1.12E+01</td><td>1.60E+00</td><td>2.28E-06</td><td>3.83E-28</td><td>3.77E-03</td><td>1.27E-01</td><td>1.75E-22</td></tr><tr><td>Mean</td><td>1.36E+00</td><td>3.60E-05</td><td>2.55E-15</td><td>6.55E-30</td><td>2.65E-22</td><td>1.10E-02</td><td>1.13E-31</td></tr><tr><td>Std.Dev</td><td>1.38E+00</td><td>2.09E-04</td><td>1.94E-16</td><td>1.02E-29</td><td>1.42E-21</td><td></td><td>2.68E-31</td></tr><tr><td rowspan=\"4\">f12</td><td></td><td>0</td><td>0</td><td>1</td><td></td><td></td><td>6.24E-02</td><td></td></tr><tr><td>+ -</td><td>12</td><td>12</td><td>11</td><td>3 8</td><td>0</td><td>1</td><td></td></tr><tr><td>~</td><td>0</td><td></td><td></td><td></td><td>12</td><td>11</td><td></td></tr><tr><td></td><td></td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td></td></tr></table></body></html>",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "除了实验结果的寻优精度和稳定性，收敛速度也是衡量算法能力的一项重要指标。图3给出了 $D = 3 0$ 时各算法在12个测试函数上优化过程的收敛曲线。为了更清晰地描述收敛过程中曲线的变化，图中的纵坐标取适应度值的对数。从图中可以看出，在没有早熟收敛的前提下，与其他6种算法相比，CA-DBSA算法在12个函数上整体来说均表现出了较快的收敛速度。除了在函数 $f _ { 8 }$ 上，本文算法迭代到5000代时仍未完全收敛，在其他函数上均在前半周期已经收敛。这得益于基于元胞自动机的多父代正交交叉算子的使用，使得CA-DBSA在搜索效率上相比于基本BSA得到了较大程度的提高。",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 5
    },
    {
        "type": "image",
        "img_path": "images/81b9fca185321975f03fcea616ee2d9936ec95810d4dd7b4064b097f16413c83.jpg",
        "img_caption": [
            "图3 $D = 3 0$ 时7种算法的收敛曲线",
            "Fig.3Convergence curves of 7algorithms at ${ \\mathrm { D } } { = } 3 0$ "
        ],
        "img_footnote": [],
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "对于智能进化算法而言，随着优化问题维度的不断增加，问题的复杂度也将会随之急剧上升。而对于多峰类型函数来说，其局部极值个数将呈现指数级别的增长。因此算法的整体性能将会受到较大影响。在此基础上，为了进一步研究本文所提算法受维度增长的影响程度，对7种算法在12个测试函数上进行了第三组 $D = 6 0$ 时的数值实验。实验结果如表4所示。从表中可以看出，当测试函数的维数从30增加到60时，相比于表3中的实验结果，各算法的收敛性能均有所下降，但是CA-DBSA受到的影响相对其他6种算法来说较小。",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "且从表中加粗部分数据结果和秩和检验的统计信息来看，12个函数的最优测试结果中有10个是由CA-DBSA算法实验所得，比表3实验结果表现更好。在OXDE中，只有在函数 $f _ { 6 }$ 和 $f _ { 9 }$ 上，OXDE的寻优结果比CA-DBSA更好。而表3中存在4个结果比CA-DBSA更优或相似。同样，30 维时的LBSA有一个函数寻优性能优于CA-DBSA，而在60 维时性能有所下降。因此，与表3对比可发现，本文算法在60维度时的整体实验结果比30维度时有所提高，展现出了较强的鲁棒性。",
        "page_idx": 6
    },
    {
        "type": "table",
        "img_path": "images/330cd67904891e5722667fc5b20588c93c090533b3681227e1703a997e30c89c.jpg",
        "table_caption": [
            "表4时7种算法的实验结果",
            "Table 4Experimental results of 7algorithms at ${ \\bf D } { = } 6 0$ "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td>函数</td><td></td><td>CLPSO</td><td>MABC</td><td>MPCO-ABC</td><td>OXDE</td><td>BSA</td><td>LBSA</td><td>CA-DBSA</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>1.33E+02</td><td>7.27E-07</td><td>5.51E-09</td><td>7.07E-11</td><td>6.63E-06</td><td>2.07E-24</td><td>1.33E-52</td></tr><tr><td>Std.Dev</td><td>4.17E+01</td><td>9.89E-08</td><td>4.62E-08</td><td>7.90E-11</td><td>3.90E-05</td><td>1.52E-26</td><td>7.29E-52</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>1.46E+02</td><td>2.37E-06</td><td>9.04E-08</td><td>5.27E-10</td><td>7.01E-06</td><td>5.96E-27</td><td>5.77E-52</td></tr><tr><td>Std.Dev</td><td>2.25E+00</td><td>5.76E-05</td><td>6.61E-08</td><td>1.19E-11</td><td>9.96E-06</td><td>3.62E-28</td><td>1.20E-53</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>3.13E+04</td><td>5.73E+04</td><td>7.48E+02</td><td>1.56E+02</td><td>2.41E+02</td><td>4.02E+02</td><td>8.73E+01</td></tr><tr><td>Std.Dev</td><td>1.94E+03</td><td>1.41E+04</td><td>4.23E+01</td><td>2.54E+02</td><td>2.23E+02</td><td>3.68E+01</td><td>3.48E+00</td></tr><tr><td rowspan=\"2\">f4</td><td>Mean</td><td>1.44E+06</td><td>4.29E+02</td><td>5.16E+05</td><td>2.91E-19</td><td>2.40E-09</td><td>7.62E-31</td><td>5.81E-69</td></tr><tr><td>Std.Dev</td><td>6.59E+03</td><td>1.28E+02</td><td>6.49E+04</td><td>5.64E-20</td><td>3.47E-09</td><td>1.26E-28</td><td>1.60E-70</td></tr><tr><td rowspan=\"2\">f5</td><td>Mean</td><td>5.02E+03</td><td>2.72E-04</td><td>7.22E-07</td><td>4.94E-05</td><td>8.79E-04</td><td>3.79E-08</td><td>4.28E-35</td></tr><tr><td>Std.Dev</td><td>7.74E+01</td><td>2.21E-06</td><td>6.36E-08</td><td>8.80E-05</td><td>6.50E-03</td><td>1.17E-06</td><td>1.15E-34</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>2.04E+01</td><td>1.52E+01</td><td>2.67E-03</td><td>2.52E-06</td><td>5.58E+00</td><td>6.40E+02</td><td>2.18E-02</td></tr><tr><td>Std.Dev</td><td>2.01E+01</td><td>8.05E+00</td><td>1.83E-04</td><td>1.50E-05</td><td>3.25E-02</td><td>3.31E+02</td><td>2.66E-04</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>1.08E+02</td><td>6.43E-01</td><td>8.04E-05</td><td>9.78E-07</td><td>1.19E-04</td><td>8.14E-09</td><td>1.83E-14</td></tr><tr><td>Std.Dev</td><td>1.05E+02</td><td>6.78E-01</td><td>1.62E-03</td><td>1.52E-08</td><td>3.76E-05</td><td>6.22E-08</td><td>1.52E-16</td></tr><tr><td rowspan=\"2\">fs</td><td>Mean</td><td>7.87E+02</td><td>1.75E+02</td><td>4.37E+01</td><td>5.17E+01</td><td>4.48E+01</td><td>8.94E+01</td><td>2.07E+01</td></tr><tr><td>Std.Dev</td><td>1.03E+01</td><td>7.58E+02</td><td>2.03E+00</td><td>6.17E+01</td><td>4.74E+01</td><td>6.25E+00</td><td>2.56E+00</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>8.72E+02</td><td>2.47E-03</td><td>2.41E-06</td><td>3.11E-11</td><td>9.87E-03</td><td>1.30E+01</td><td>5.13E-10</td></tr><tr><td>Std.Dev</td><td>3.07E+02</td><td>5.95E-04</td><td>3.72E-06</td><td>3.36E-10</td><td>1.62E-01</td><td>5.34E+01</td><td>7.12E-10</td></tr><tr><td rowspan=\"2\">f</td><td>Mean</td><td>1.63E+04</td><td>1.05E+04</td><td>7.81E+02</td><td>3.77E+03</td><td>3.57E+03</td><td>7.71E+03</td><td>1.37E+02</td></tr><tr><td>Std.Dev</td><td>1.87E+04</td><td>8.87E+03</td><td>6.33E+02</td><td>3.57E+03</td><td>3.95E+03</td><td>5.22E+03</td><td>2.37E+00</td></tr><tr><td rowspan=\"2\">fu</td><td>Mean</td><td>1.66E+02</td><td>1.85E+00</td><td>5.18E+02</td><td>7.10E-02</td><td>2.19E-01</td><td>1.06E+01</td><td>1.25E-05</td></tr><tr><td>Std.Dev</td><td>1.71E+01</td><td>7.51E-01</td><td>1.58E+01</td><td>9.98E-02</td><td>2.23E-01</td><td>2.05E+00</td><td>4.69E-04</td></tr><tr><td rowspan=\"4\">f2</td><td>Mean</td><td>4.14E+01</td><td>5.89E-01</td><td>1.73E-09</td><td>6.33E-14</td><td>3.28E-08</td><td>1.49E+01</td><td>8.71E-18</td></tr><tr><td>Std.Dev</td><td>3.60E+01</td><td>3.23E-02</td><td>3.57E-07</td><td>1.26E-13</td><td>2.10E-07</td><td>6.37E+02</td><td>7.11E-18</td></tr><tr><td>+</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td><td></td></tr><tr><td></td><td>12</td><td>12</td><td>11</td><td>10</td><td>12</td><td>12</td><td></td></tr><tr><td></td><td>~</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td></td></tr></table></body></html>",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "5 结束语",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "基本BSA算法具有较强的全局搜索能力，但是局部搜素能力较为欠缺，且收敛速度较慢、寻优精度不高。本文对BSA的变异和交叉操作进行改进，提出一种新的基于元胞自动机的多父代正交交叉算子，有效提高了算法的搜索效率和精度。并在交叉过程中引入了随机扰动策略，避免了算法执行中后期易陷入局部最优的可能。同时，提出一种动态变异方程，并在交叉前期执行交叉选择机制，在算法进化的不同阶段较好的平衡了整体的全局和局部搜索能力。最后，通过选取的标准函数和其他6种算法进行数值实验。结果表明，本文改进的算法相对基本BSA和参考文献中的5种算法而言，在收敛速度和精度上都具有明显的优势，搜索性能得到了较大的提升。",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "参考文献：",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "[1]Holland JH.Adaptation in natural and artificial systems ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "[M].Cambridge:MITPress,1992.   \n[2]Kennedy J,EberhartR.Particle sWarm optimization [C]/Proc of IEEE International Conference on Neural Networks.Piscataway,NJ:IEEE Press,1995:1942-1948.   \n[3]Storn R,Price K.Differential evolution:a simple and efficient heuristic for global optimization over continuous spaces [J].Journal of Global Optimization,1997,11(3): 341-359.   \n[4]Karaboga D,Basturk B.A powerful and efficient algorithm for numerical function optimization:artificial bee colony(ABC) algorithm [J]. Journal of Global Optimization,2007,39(3): 459-471.   \n[5]Liang Jing,Qin Kai,Suganthan P N,et al. Comprehensive learning particle swarm optimizer for global optimization of multimodal functions [J].IEEE Trans on Evolutionary Computation,2Oo6,10(3): 281-295.   \n[6]夏学文，刘经南，高柯夫,等.具备反向学习和局部学习能力的粒子群 算法[J].计算机学报，2015,38(7):1397-1407.(Xia Xuewen,Liu Jingnan,Gao Kefu,et al.Particle swarm optimization algorithm with reverse-learning and local-learning behavior [J].Chinese Journal of Computers,2015,38(7): 1397-1407.)   \n[7]Wang Yong,Zhang Qingfu.Enhancing the search ability of differential evolution through orthogonal crossover [J].Information Sciences,2012, 185(1): 153-177.   \n[8] 周晓根，张贵军，郝小虎,等．一种基于局部 Lipschitz 下界估计支撑 面的差分进化算法 [J].计算机学报，2016.39(12):2631-2651.(Zhou Xiaogen，Zhang Guijun,Hao Xiaohu,et al.Differential evolution algorithmbasedon local Lipschitzunderestimatesupporting hyperplanes[J].ChineseJournalofComputers,2016,39(12): 2631-2651. )   \n[9]Gao Weifeng,Liu Sanyang.A modified artificial bee colony algorithm [J].Computers & Operations Research,2012,39(3): 687-697.   \n[10]周新宇，吴志健，王明文．基于正交实验设计的人工蜂群算法[J]. 软件学报,2015,26(9):2167-2190.(Zhou Xinyu,Wu Zhijian,Wang Mingwen．Artificial bee colony algorithm based on orthogonal experimental design [J].Journal of Software,2015,26(9):2167-2190.)   \n[11] Civicioglu P.Backtracking search optimization algorithm for numerical optimization problems [J].Applied Mathe-Matics& Computation,2013, 219(15): 8121-8144.   \n[12]田文凯，刘三阳，王晓娟．基于差分进化的回溯搜索优化算法研究 与改进[J]．计算机应用研究,2015,32(6):1653-1656.(Tian Wenkai, Liu Sanyang,Wang Xiaojuan. Study and improvement of backtracking search optimization algorithm based on differential evolution [J]. Application Research of Computers,2015,32(6):1653-1656.)   \n[13]李牧东，赵辉，翁兴伟．具有广泛学习策略的回溯搜索优化算法 [J]. 系统工程与电子技术,2015,37(4):958-963.(Li Mudong，Zhao Hui, Weng Xingwei.Backtracking search optimization algorithm with comprehensive learning strategy [J].Systems Engineeringand Electronics,2015,37(4): 958-963.）   \n[14] Chen Debao,Zou Feng,Lu Renquan，et al.Learning backtracking search optimisation algorithm and its application [J].Information Sciences,2017,376:71-94.   \n[15]MariotL,Picek S,Jakobovic D,et al.Evolutionary algorithms for the design of orthogonal latin squares based on cellular automata [Cl// Proc of Genetic and Evolutionary Computation Conference.New York:ACM Press,2017:306-313.   \n[16]贺智明，宋建国，梅宏标．结合元胞自动机的果蝇优化算法[J].计 算机应用，2014,34(8):2295-2298.(He Zhiming,Song Jianguo,Mei Hongbiao.Fruit fly optimization algorithm based on cellular automata [J].Journal of Computer Applications,2014,34(8):2295-2298.)   \n[17]程健，金菊良，周玉良，等．基于正交试验和元胞自动机模型的加速 并行遗传算法[J].系统工程理论方法应用，2006(4)：364-367.(Cheng Jian,Jin Juliang,Zhou Yuliang,et al.Orthogonal design and celular automata based acceleration parallel genetic algorithm [J]. Systems Engineering-Theory Methodology Applications.2006(4): 364-367.)   \n[18]蔡自兴，江中央，王勇，等．一种新的基于正交实验设计的约束优化 进化算法 [J].计算机学报，2010,33(5):855-864.(Cai Zixing,Jiang Zhongyang，Wang Yong，et al.A novel constrained optimization evolutionary algorithm based on orthogonal experimental design [J]. Chinese Journal of Computers,2010,33(5): 855-864.)   \n[19]李康顺，左磊，李伟．基于单形正交实验设计的差分演化算法[J]. 计算机应用,2016,36(1):143-149.(Li Kangshun,Zuo Lei,Li Wei. Novel differential evolution algorithm based on simplex-orthogonal experimental design [J]. Journal of Computer Applications,2016,36(1): 143-149.)   \n[20] Abunaser A,Alshattnawi S.Hybridizing artificial bee colony algorithm with multi-parent crossover operator [J]. International Journal of Applied Metaheuristic Computing,2015,6 (2): 608-614.   \n[21]张锦华，宋来锁，张元华，等．加权变异策略动态差分进化算法[J]. 计算机工程与应用,2017,53(4):156-162.(Zhang Jinhua,Song Laisuo, Zhang Yuanhua,et al.Dynamic differential evolution algorithm with weighted mutation strategy [J].Computer Engineering and Applications, 2017,53 (4): 156-162.) ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 7
    }
]