[
    {
        "type": "text",
        "text": "无向图中连通支配集问题的精确算法",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "周晓清1,2，叶安胜²†，张志强²",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "(1．电子科技大学 计算机科学与工程学院，成都 611731;2．成都大学 信息科学与工程学院，成都 610106)",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "摘要：图 $G = ( V , E )$ 的一个支配集 $D \\subseteq V$ 是一个顶点子集，使得图中每一个顶点要么在 $D$ 中，要么至少与 $D$ 中的一个顶点相连。连通支配集问题是找到一个顶点数最小的支配集S，并且S的导出子图 $G [ \\mathrm { { S } ] }$ 是连通图。该问题是一个经典的 NP 难问题，可应用于连通设施选址、自适应网络等领域。针对无向图中连通支配集问题，仔细分析该问题的图结构性质，挖掘出若干有效的约简规则和分支规则，设计了一个分支搜索算法，并采用了测量治之方法分析算法的运行时间，最终得到了一个运行时间复杂度为 $O ^ { * } ( 1 . 9 3 ^ { n } )$ 的精确算法。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "关键词：NP难问题；精确算法；测量治之；连通支配集问题 中图分类号：TP301.5 doi:10.3969/j.issn.1001-3695.2018.03.0154 ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Exact algorithms for connected dominating set in undirected graphs ",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Zhou Xiaoqing1, ², Ye Ansheng²†, Zhang Zhiqiang² (1.SchoolofComputer Science&Engineering,UniversityofElectronicScience&TechnologyofChina,Chengdu 61731, China;2.CollegeofInformation Science& Engineering,Chengdu University,Chengdu 610106,China) ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Abstract: A dominating set $D \\subseteq V$ of a graph $G = ( V , E )$ is a subset of vertices,such that every vertex of G is either in D, oradjacent toatleastone vertexinD.Theconnected dominatingset problemasks to findadominating setSwith minimum number of vertices and the induced subgraph $G [ S ]$ of $s$ is connected. The connected dominating set problem is a classical NP-hard problem,which could beapplied to connected facility location,ad-hoc networksand many other areas.For the conecteddominatingsetprobleminundirected graphs,this papercarefullyaalyzes testructuralproperties,exploresanumber of fectivereduction rulesas wellas branching rulesand provides abranch-and-search algorithm.A measure-and-conquer method is also introduced to analyzetherunning time bound.Finaly,anexact algorithm with arunning timecomplexityof $O ^ { * } ( 1 . 9 3 ^ { n } )$ is obtained. ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Key words: NP-hard problem; exact algorithms; measure-and-conquer; connected dominating set problem ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "0 引言",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "NP 和NP完全的概念是Cook[1]于1971年提出来的，自提出后NP理论得到广泛研究。当 $P \\neq N P$ 时，NP完全问题不存在多项式时间算法。对于许多 NP 难问题，Impagliazzo 等人[2]证明不存在亚指数时间算法。此外，这些问题没有或很难获得近似算法。例如，著名的3-SAT问题，要么为真要么为假，采用近似算法求解毫无意义。在 $P { = } N P$ 这个自前被广泛认为不大可能的结果出现之前，要得到NP难问题的准确解只能采用精确算法[3]。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "非平凡精确算法的历史可以追溯到1962 年，Held 等人[4]对TSP（traveling salesman problem）设计了运行时间为 $O ( 2 ^ { n } n ^ { 2 } )$ 的动态规划算法（其中 $n$ 为图中的顶点数)，这也是该问题迄今为止最快算法之一，该问题是否存在运行时间为 $O ^ { * } ( 1 . 9 9 ^ { n } )$ 的算法已经成为计算理论中一个著名的公开难题。另一个著名问题是最大独立集问题(maximum independent set problem)，1977 年Tarjan 等人[5]提出了运行时间为 $O ( 2 ^ { n / 3 } )$ 的最大独立集算法。经过一系列学者的研究，1986年Robson[将该问题运行时间的上界改进到 $O ( 2 ^ { 0 . 2 7 6 n } )$ ，目前该问题的运行时间被改进到$O ^ { * } ( 1 . 1 9 9 6 ^ { n } )$ [7],然而将这个上界改进到 $1 . 2 ^ { n }$ 以下用了30多年。对于不同的NP难问题，目前已知的精确算法的时间复杂度之间差距较大，如前所提及到TSP问题和最大独立集问题。那么在时间复杂度较差的各种问题之间是否存在联系，或者当解决某个NP 难问题是否有助于其他NP难问题的解决，或者是否可以以某种方式对经典 NP完全问题进行分类后预测较差时间复杂度的算法最好能有多好，这些都是需要考虑的问题，有助于更好的认识NP完全问题的计算复杂性。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "对于支配的概念，1962年Claude[8]首次描述了现代图的支配概念。同一年，Ore[第一次在文献中使用了支配集（dominatingset）这个术语。支配集包括顶点支配集和边支配集，与此同时，支配集问题包含顶点支配问题和边支配问题。最小顶点支配集问题（dominating set problem)是一个经典的 NP难问题[10]，2004年Fomin等人[11]设计了运行时间为$O ^ { * } ( 1 . 9 3 7 8 ^ { n } )$ 的精确算法，第一次突破了 $2 ^ { n }$ 这个平凡时间界,对于该问题目前已知的最佳精确算法的运行时间是$O ^ { * } ( 1 . 4 9 6 9 ^ { n } )$ [12]。对于最小边支配集问题（edge dominating setproblem），Yannakakis 等人[13]证明其是NP难的，2008 年Schiermeyer[14]第一次打破了 $2 ^ { n }$ 这个平凡时间界，目前该问题已知的最佳精确算法的运行时间为 $O ^ { * } ( 1 . 3 1 6 0 ^ { n } )$ [15]。对于本文研究的连通支配集问题（connected dominating set problem），Garey等人[10]证明该问题是NP难的。2008年Fomin等人[16]第一次打破了 $2 ^ { n }$ 这个平凡时间界，提出了运行时间为 $O ^ { * } ( 1 . 9 4 0 7 ^ { n } )$ 的精确算法。从表面来看，连通支配集问题和支配集问题紧密相连，似乎可以用解决支配集问题的方法来解决连通支配集问题。但是，实际上这样是行不通的，因为从精确算法的角度来看这两者之间具有很大的不同。事实上，连通支配集问题是属于一类称为非局部性的问题（non-localproblems)，通常这种非局部性问题都很难处理，例如经典的TSP问题。由于解决支配集问题的精确算法通常是基于问题的局部结构，不能很好的抓住全局连通的这种属性，所以很难将解决支配集的技术用来解决连通支配集。类似这种非局部性问题有反馈顶点集问题（feedbackvertex set problem）、斯坦纳树问题（Steiner tree problem）等。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "图 $G$ 的一个支配集是一个顶点子集 $D$ 使得图中的顶点如果不在 $D$ 中那么至少与 $D$ 中一个顶点相连。最小顶点支配集问题就是在图中找出一个顶点数最少的支配集，该问题是一个经典的NP难问题[10]。如果对支配集中的顶点加一些约束条件，那么最小顶点支配集问题可以转化成另外一些NP难问题。若要求支配集 $D$ 中的任意两个顶点之间没有边相连，即 $D$ 是一个独立集，那么该问题就是独立支配集问题；若要求支配集 $D$ 中的任意两个顶点之间都有边相连，即 $D$ 是一个团，那么该问题就是支配团问题；若要求支配集 $D$ 的导出子图为一个连通图，该问题就是连通支配集问题。本文解决的问题就是连通支配集问题。图 $G$ 的一个连通支配集是一个顶点子集S，要求S不仅为支配集而且其导出子图是连通的。最小连通支配集问题就是在图中找出一个顶点数最小的连通支配集。该问题等价于寻找图 $G$ 的一棵生成树，要求该生成树的叶子结点数达到最大。连通支配集在连通的设施选址、操作系统、无线自适应网络方面都有广泛的应用[17\\~22]。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "本文针对连通支配集问题给出了运行时间为 $O ^ { * } ( 1 . 9 3 ^ { n } )$ 的精确算法，其算法基本思想源自于Fomin 等人[16]设计的精确算法的思想“保持连通”，即在递归过程中所产生的部分解必须是连通的，同时采用测量治之（measure and conquer）[23,24]的方法设计递归算法和分析递归算法的时间复杂度。在使用测量治之分析递归算法的时间复杂度时，文中采用了非常简单的方式来设置度量，同时对时间复杂度的分析也非常清晰，具体参见第4小节。文中仔细分析连通支配集问题的图结构性质，细致地挖掘了该问题相关的性质，在此基础上设计了有效的约简规则和分支规则，使得该问题得以简化。针对连通支配集问题设计的约简规则和分支规则，降低了原问题的求解规模和难度，结合启发式算法在处理连通支配集问题的具体应用中会更加高效",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "1 符号和问题定义",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "简单图是指没有平行边和自环的图，本文涉及到的所有图均指无向简单图。设 $G = ( V , E )$ 表示一个顶点集为 $V$ 和边集为$E$ 的图，其中 $\\mid V \\mid = n$ 和 $\\mid E \\mid = m$ 。如果一个顶点子集仅包含一个元素 $\\{ \\nu \\}$ ，可以简单记为 $\\nu$ 。对于图 $G$ 中的任意一个顶点 $\\nu$ ，用 $N ( \\nu ) { = } \\{ u \\in V : u \\nu \\in E \\}$ 表示顶点 $\\nu$ 的开邻集，用$N [ \\nu ] { = } N ( \\nu ) \\cup \\nu$ 表示顶点 $\\nu$ 的闭邻集。 $N _ { 2 } ( \\nu )$ 表示距离顶点 $\\nu$ 为2的顶点集合。 $d ( \\nu )$ 表示顶点 $\\nu$ 的度，即图中边的一个端点为 $\\nu$ 的条数。在简单图中， $d ( \\nu ) = \\mid N ( \\nu ) \\mid$ 始终成立。对于一个顶点子集 $X$ ，令 $\\begin{array} { r } { \\boldsymbol { \\cdot } \\boldsymbol { N } ( \\boldsymbol { X } ) = \\bigcup _ { v \\in \\boldsymbol { X } } \\boldsymbol { N } ( v ) \\backslash \\boldsymbol { X } \\circ \\ G [ \\boldsymbol { X } ] } \\end{array}$ 表示由顶点子集$X \\subseteq V$ 导出的子图， $G [ V \\backslash X ]$ 也可以简写为 $G \\backslash X$ 。如果顶点子集 $X$ 的导出子图 $G [ X ]$ 是连通图，则称顶点子集 $X$ 为连通子集。对于算法运行时间分析，用 $\\boldsymbol { O } ^ { * }$ 符号省略多项式部分，如对 $f ( n )$ 和 $g ( n )$ 两个函数，用 $f ( n ) = O ^ { * } ( g ( n ) )$ 表示$f ( n ) = g ( n ) \\cdot n ^ { O ( 1 ) }$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "为了不失一般性，文中作以下假设：文中所提及的图均为连通图，否则该问题无解；图 $G$ 的最小连通支配集的大小至少为2，否则该问题可以在多项式时间内解决。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "在算法的执行过程中，某些顶点一定会被包含最终解中，用 $S \\subseteq V$ 表示这些顶点构成的集合，即顶点集 $s$ 中的所有顶点都会在最终解中，其中 $\\vert S \\vert \\ge 2$ 并且 $G [ S ]$ 是连通的。同时，在算法执行过程中，某些顶点一定不会在最终解中，用顶点集$D \\subseteq V$ 表示这些顶点构成的集合，即在算法执行过程中将这些顶点从图中删除。假设用OPT表示最优解，那么顶点集 $s$ 中的所有顶点一定在 $O P T$ 中，顶点集 $D$ 中的所有顶点一定不在OPT中，即 $S \\subseteq O P T$ 且 $D \\cap O P T = \\phi$ 。用 $A = V \\setminus ( S \\cup D )$ 表示图 $G$ 中即没有被选入集合 $s$ 中也没有被选入集合 $D$ 中的顶点，即还未被处理的顶点，称为可用顶点集。如果删除 $A$ 中的一个顶点 $\\nu$ 使得问题实例无解，则称顶点 $\\nu$ 为必选点。如果$A$ 中的一个顶点 $\\nu$ 至少与集合 $S$ 中的一个顶点相邻，那么称顶点 $\\nu$ 为候选点，否则称为自由点。用 $C$ 表示候选点构成的集合，$\\textstyle C = \\bigcup _ { \\nu \\in S } N ( \\nu ) \\bigcap A$ 用 $F$ 表示自由点构成的集合， $F = A \\setminus C$ 如果图 $G$ 中的一个顶点 $\\nu$ 至少与集合 $s$ 中的一个顶点相邻，那么称集合 $s$ 支配顶点 $\\nu$ 。本文考虑的是如下一个带约束的最小连通支配集问题：",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "带约束的最小连通支配集问题",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "输入：一个无向图 $G = ( V , E )$ 和 $G$ 的两个顶点子集 $S , D \\subseteq V$ ，其中导",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "出子图 $G [ S ]$ 为连通图。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "问题：找出图 $G$ 的一个最小顶点子集 $Y \\subseteq V$ 满足如下性质： $Y$ 是一个支配集， $S \\subseteq Y$ 且 ${ \\cal D } \\cap { \\cal Y } = \\phi$ ，导出子图 $G [ Y ]$ 为连通图。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "可以看出，当 $s$ 包含图中任意两个相邻点 $u$ 和 $\\nu$ 时，带约束的最小连通支配集问题就是求包含 $u$ 和 $\\nu$ 的最小连通支配集。本文研究这种带约束条件的问题，其主要原因是在分支搜索算法中某些分支会要求将一些顶点保留在最后的解中，那么可以直接将这些顶点加入 $s$ 中。对于带约束的最小连通支配集问题，任意一个包含S中所有顶点且是连通支配集的顶点子集称为该问题的一个可行解。当一个可行解的大小达到最小时，就称该可行解为最优解，在本文中将一个最优解简称为一个解。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "2 算法设计",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "2.1初步思想 ",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "由于最小连通支配集问题具有连通的全局属性，算法设计的初步思想是猜测图中的任意两个相邻顶点 $\\nu _ { 1 }$ 和 $\\nu _ { 2 }$ 可能在某些最优解中，然后任意拿出 $A$ 中一个候选点 $\\nu$ 分两种情况进行讨论：要么 $\\nu$ 在 $Y$ 中；要么 $\\nu$ 不在 $Y$ 中。如果 $\\nu$ 在 $Y$ 中，那么直接将 $\\nu$ 加入 $s$ 中；如果 $\\nu$ 不在 $Y$ 中，那么从图中直接删除 $\\nu$ 。如此不断的进行分支搜索，直到 $A$ 为空集或 $A$ 中不存在任何候选点，这样就可以解决该问题。但是这种算法思想在理论上分析只能得到 $O ^ { * } ( 2 ^ { n } )$ 的运行时间界，很长时间都未有人突破这个简单的运行时间界，直到Fomin等人用测量治之方法来解决该问题[16]。在解决连通支配集问题时，Fomin等人的主要思想还是不断选出一个顶点 $\\nu$ 分两种情况进行讨论：要么将 $\\nu$ 保留到最后的解中，要么从图中删除，只是将一个顶点加入解时一定要对解“保持连通”。本文同样遵循这种“保持连通”的思想，并且在处理 $A$ 中的候选点进行了更为细致的思考。在考虑将 $A$ 中的一个候选顶点 $\\nu$ 加入解的目的有两个：一是为了支配 $\\nu$ 的所有自由点邻居；二是为了连通 $\\nu$ 的某一个自由点邻居。对于前一种情况，当将 $\\nu$ 加入解后，可以简单的将 $\\nu$ 的所有自由点邻居直接删除；对于后一种情况，当将 $\\nu$ 加入解后，可以将 $\\nu$ 的某一个自由点邻居加入解中。本文就是基于这样一个思想，不断的处理 $A$ 中的候选点，当 $A = \\phi$ 或者不存在候选点时，算法要么找到一个解，要么解不存在，最后采用测量治之方法对算法的进行分析和设计，从而将算法的运行时间界进一步进行改进。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "2.2定理和性质 ",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "在多项式时间内如果通过实例 $I$ 的一个解Y可以构造出另一个问题实例 $I ^ { \\prime }$ 的一个解 $Y ^ { \\prime }$ ，那么称问题实例 $I$ 等价问题实例 $I ^ { \\prime }$ ，反之亦然。下面将先证明问题实例的等价性质，在等价性质的基础上定义一些约简操作，通过这些约简操作简化原问题实例。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "定理1对于一个带约束的最小连通支配集问题实例$\\boldsymbol { I } = ( G , S , D )$ ，若 $I$ 存在一个解不包含某个顶点 $\\nu$ ，则删除 $\\nu$ 以后的实例 $I ^ { \\prime } { = } ( G \\setminus \\nu , S , D \\cup \\{ \\nu \\} )$ 的任意一个解是原问题实例 $I$ 的一个解；若 $I$ 存在一个解包含某个顶点 $u$ ，则将 $u$ 加入$s$ 以后的实例 $I ^ { \\prime \\prime } { = } ( G , S \\cup \\{ u \\} , D )$ 的任意一个解是原问题实例 $I$ 的一个解。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "证明设 $G ^ { \\prime } { = } G \\backslash \\nu$ ， $Y ^ { \\prime }$ 为 $I ^ { \\prime }$ 的任意一个最优解。因为$G$ 是 $G$ 的一个子图，所以 $Y ^ { \\prime }$ 也是 $I$ 的一个可行解。假设实例$I$ 的一个最优解Y不包含顶点 $\\nu$ ，那么 $Y$ 仍然是 $I ^ { \\prime }$ 的一个可行解。这种情况下有",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\vert Y \\vert { \\leq } \\vert Y ^ { \\prime } \\vert .\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "此时 $Y ^ { \\prime }$ 是 $I$ 的一个最优解。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "令 $Y \"$ 为 $I \"$ 的任意一个最优解。因为 $Y \"$ 的导出子图为连通图，因此 $Y$ ”是 $I$ 的一个可行解。假设实例 $I$ 的一个最优解Y包含顶点 $u$ ，那么Y仍然是 $I$ \"的一个可行解。这种情况下有",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\left| { \\cal Y } \\left| \\leq \\right| { \\cal Y } \" \\right| .\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "此时 $Y \"$ 是 $I$ 的一个最优解。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "通过定理1可以得到，如果知道某个顶点在一个最优解中时，根据该定理可以将顶点加入 $s$ 中，如果知道某个顶点不在一个最优解时，那么可以直接删除该顶点。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "性质1对于一个带约束的最小连通支配集问题实例$\\boldsymbol { I } = ( G , S , D )$ ，如果存在一个候选顶点 $\\nu$ 是必选点，则将顶点$\\nu$ 加入 $s$ □",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "由于顶点 $\\nu$ 为必选点，删除 $\\nu$ 后问题实例 $I$ 无解，那么 $\\nu$ 必须在问题实例最后的解中，根据定理1显然可知性质1的正确性。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "性质2如果存在两个候选顶点 $\\nu$ 和 $u$ ，根据性质1可知这两个顶点都不是必选点，假设 $N ( \\nu ) \\bigcap F \\subseteq N ( u ) \\bigcap F$ ，那么将顶点 $\\nu$ 加入 $D$ 中。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "假设存在一个最优解 $O P T$ 包含顶点 $\\nu$ ，由于顶点 $\\nu$ 所支配的自由点全部被顶点 $u$ 所支配，而顶点 $\\nu$ 和 $u$ 本身已经被支配，那么存在另一个不包含 $\\nu$ 且大小至多为 $| O P T |$ 的可行解$O P T ^ { \\prime } { = } O P T \\backslash \\{ \\nu \\} \\cup \\{ u \\}$ ，所以顶点 $\\nu$ 可以删除。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "性质 3如果存在一个可用点 $\\nu$ 不支配任何的自由点，那么将顶点 $\\nu$ 加入 $D$ 中。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "由于顶点 $\\nu$ 不支配任何的自由点，所以 $\\nu$ 的所有邻居都为候选点，且所有候选点都与 $S$ 连通，因此从任何可行解中移除$\\nu$ 都能保持解的可行性。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "根据性质3对图进行约简后，可以很容易得到，如果图中存在一个候选点 $\\nu$ ，那么 $\\nu$ 至少与一个自由点相邻，否则可直接将 $\\nu$ 加入 $D$ 中。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "性质4假设图 $G$ 中存在一个候选点 $\\nu$ 支配一个可用点$w$ ，如果将 $\\nu$ 加入S后，可用点 $w$ 不再支配任何的自由点，那么可以将 $w$ 加入 $D$ 中。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "因为将候选点 $\\nu$ 加入 $s$ 后，可用点 $w$ 不再支配任何的自由点，根据性质3可知，当一个可用点不再支配任何的自由点时，可将该顶点加入 $D$ 中。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "根据性质4对图进行约简后，可以很容易的得到，如果图$G$ 中存在一个候选点 $\\nu$ 支配了一个可用点 $w$ ，那么 $w$ 必然支",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "配另外的自由点 $u \\not \\in N ( \\nu )$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "性质5假设图 $G$ 中存在一个候选点 $\\nu$ 仅支配一个自由点$w$ ，设 $U { = } \\{ u _ { 1 } , u _ { 2 } , { \\ldots } , u _ { k } \\} { = } N ( w ) \\cap A \\setminus N [ \\nu ]$ ，如果实例 $\\boldsymbol { I } = ( G , S , D )$ 存在一个最优解 $O P T$ 包含 $\\nu$ 但不包含 $w$ ，那么可以将 $U$ 加入$D$ 中。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "证明设 $O P T$ 为实例 $I = ( G , S \\cup \\{ \\nu \\} , D \\cup \\{ w \\} )$ 的最优解,那么 $\\nu \\in O P T$ 和 $w \\not \\in O P T$ 。为了构造矛盾假设 $u _ { i } \\in U$ 且$u _ { i } \\in O P T$ ，那么 $O P T { = } O ^ { \\prime } \\cup \\{ \\nu , u _ { i } \\}$ （ $O ^ { \\prime }$ 为某些合适的顶点集合)。由于 $w \\not \\in O P T$ ， $O P T ^ { \\prime } { = } O ^ { \\prime } \\cup u _ { i }$ 仍然连通，而 $\\nu$ 只支配 $w$ ， $w$ 又被 $u _ { i }$ 支配，所以 $O P T ^ { \\prime }$ 是一个支配集，因此 $O P T ^ { \\prime }$ 是一个大小为$| O P T | .$ -1的连通支配集，这与 $O P T$ 是最优解相矛盾，见图1中的情况1。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "性质6假设图 $G$ 中存在一个候选点 $\\nu$ 仅支配一个自由点$w$ ，且 $w$ 也仅支配一个自由点 $u \\not \\in N ( \\nu )$ ，如果实例$\\boldsymbol { I } = ( G , S , D )$ 存在一个包含 $\\nu$ 但不包含 $w$ 的最优解 $O P T$ ，那么存在另一个不包含 $\\nu$ 的最优解 $O P T ^ { \\prime }$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "证明设OPT为实例 $I = ( G , S \\cup \\{ \\nu \\} , D \\cup \\{ w \\} )$ 的最优解，那么 $\\nu \\in O P T$ 和 $w \\not \\in O P T$ 。假设 $u \\in O P T$ ，那么存在一个可行解 $O { = } O P T \\backslash \\{ \\nu \\}$ ，这与 $O P T$ 是最优解相矛盾，所以$u \\not \\in O P T$ 。由于最优解 $O P T$ 会支配 $u$ ，所以 $O P T$ 中至少包含一个 $u$ 的除 $w$ 之外的邻居 ${ \\mathfrak { x } } \\subseteq N ( u ) \\backslash \\{ \\mathfrak { w } \\}$ ，那么$O P T { = } O ^ { \\prime } \\cup \\{ \\nu , x \\}$ （ $O ^ { \\prime }$ 为某些合适的顶点集合)。由于 $\\nu$ 是候选点（ $\\nu$ 已经被支配)，且 $\\nu$ 只支配顶点 $w$ ，而 $w$ 也只支配 $u$ ，所以可以将最优解 $O P T$ 中的 $\\nu$ 换成 $u$ ，得到另一个可行解$O P T ^ { \\prime } { = } O ^ { \\prime } \\cup \\{ u , x \\}$ ，又 $\\vert O P T ^ { \\prime } \\vert { = } \\vert O P T _ { \\ l }$ ，那么 $O P T ^ { \\prime }$ 是最优解，所以可以抛弃 $\\nu$ ，见图1中的情况2。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "·表示已被选择的顶点A△ O 表示未被选择的顶点情况1 情况2",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "定理2.给出一个实例 $\\boldsymbol { I } = ( G , S , D )$ ，假设图 $G$ 存在一个候选点 $\\nu$ 仅支配一个自由点 $w$ ，实例 $I$ 存在一个最优解 $Y$ 使得如下成立：",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "a)如果 $w$ 仅支配一个自由点 $u \\not \\in N ( \\nu )$ ，要么 $\\nu \\not \\in Y$ ，要么$\\{ \\nu , w \\} \\in Y$ ;",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "b）如果 $w$ 至少支配两个自由点，设自由点集合为$U { = } \\{ u _ { 1 } , u _ { 2 } , { \\ldots } , u _ { k } \\} { = } N ( w ) \\cap A \\setminus N [ \\nu ]$ ，其中 $k \\geq 2$ ，那么要么 $\\nu \\not \\in Y$ ，要么 $\\{ \\nu , w \\} \\in Y$ ，要么 $\\nu \\in Y$ 且 $\\{ w \\cup U \\} \\not \\in Y$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "证明：a）设 $Y ^ { \\prime }$ 为一个问题实例的最优解，假设 $Y ^ { \\prime }$ 包含顶点 $\\nu$ ，否则a）直接成立。 $Y ^ { \\prime }$ 必然不包含顶点 $u$ ，否则存在一个包含 $u$ 但不包含 $\\nu$ 可行解 $Y \"$ ，使得 $\\big | Y ^ { \\boldsymbol { \\prime } } \\big | { < } \\big | Y ^ { \\boldsymbol { \\prime } } \\big |$ ，这与 $Y ^ { \\prime }$ 是最优解相矛盾。又 $Y ^ { \\prime }$ 为最优解必然支配顶点 $u$ ，所以至少 $u$ 的一个邻居在 $Y ^ { \\prime }$ ，如果 $w$ 在 $Y ^ { \\prime }$ 中，a)直接成立，如果 $w$ 不在 $Y ^ { \\prime }$ 中，根据性质6可知，可以找到另外一个不包含 $\\nu$ 的最优解，所以a）也成立。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "b）设 $Y ^ { \\prime }$ 为一个问题实例的最优解，假设Y'包含顶点 $\\nu$ ，否则b）直接成立。 $Y ^ { \\prime }$ 必然不包含 $u _ { i }$ ，假设 $Y ^ { \\prime }$ 包含 $u _ { i }$ ，那么存在一个包含 $u _ { i }$ 但不包含 $\\nu$ 可行解 $Y$ \"，使得 $\\big | Y ^ { \\prime \\prime } \\big | { < } \\big | Y ^ { \\prime } \\big |$ ，这与 $Y ^ { \\prime }$ 是最优解相矛盾，所以 $Y ^ { \\prime }$ 必然不包含 $u _ { i }$ 。又 $Y ^ { \\prime }$ 为最优解必然支配顶点 $u _ { i }$ ，所以 $u _ { i }$ 的邻居中至少有一个在 $Y ^ { \\prime }$ ，如果 $w$ 在 $Y ^ { \\prime }$ 中，b）直接成立，如果如果 $w$ 不在 $Y ^ { \\prime }$ 中，根据性质5可知，可以直接将 $U$ 加入 $D$ 中，所以b）成立。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "综上所述，定理2成立。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "根据定理2对图进行约简后，可以很容易得到，如果图中存在一个候选点 $\\nu$ ，那么 $\\nu$ 至少与两个自由点相邻。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "性质7假设图 $G$ 存在一个候选点 $\\nu$ 仅支配了两个自由点$\\{ w _ { 1 } , w _ { 2 } \\}$ ，设 $U _ { i } = \\{ u _ { i , 1 } , u _ { i , 2 } , . . . , u _ { i , k } \\} = N ( w _ { i } ) \\bigcap A \\backslash N [ \\nu ]$ ，如果实例$\\boldsymbol { I } = ( G , S , D )$ 存在一个最优解 $O P T$ 包含 $\\nu$ 但不包含 $\\{ w _ { 1 } , w _ { 2 } \\}$ ，那么或者将 $U _ { 1 }$ 加入 $D$ 中，或者将 $U _ { 2 }$ 加入 $D$ 中。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "证明设 $O P T$ 为实例 $I = ( G , S \\cup \\{ \\nu \\} , D \\cup \\{ w _ { 1 } , w _ { 2 } \\} )$ 的最优解，那么 $\\nu \\in O P T$ 和 $\\{ w _ { 1 } , w _ { 2 } \\} \\not \\in O P T$ 。为了构造矛盾假设$\\{ u _ { 1 , j } , u _ { 2 , l } \\} \\in O P T$ ，其中 $j , l = \\{ 1 , 2 , . . . , k \\}$ ，那么$O P T = O ^ { \\prime } \\cup \\{ \\nu , u _ { 1 , j } , u _ { 2 , l } \\}$ （ $O ^ { \\prime } { \\mathfrak { s } }$ 为某些合适的顶点集合)。由于顶点$\\{ w _ { 1 } , w _ { 2 } \\} \\not \\in O P T$ ， $O P T ^ { \\prime } = O ^ { \\prime } \\cup \\{ u _ { 1 , j } , u _ { 2 , l } \\}$ 仍然连通，而 $\\nu$ 只支配$\\{ w _ { 1 } , w _ { 2 } \\} , \\{ w _ { 1 } , w _ { 2 } \\}$ 又分别被 $\\{ u _ { 1 , j } , u _ { 2 , l } \\}$ 支配，所以 $O P T ^ { \\prime }$ 是一个支配集，因此 $O P T ^ { \\prime }$ 是一个大小为 $\\left| O P T \\right| -$ 1的连通支配集，这与OPT是最优解相矛盾，见图2中的情况3。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "性质8假设图 $G$ 存在一个候选点 $\\nu$ 仅支配了两个自由点$\\{ w _ { 1 } , w _ { 2 } \\}$ ，且 $w _ { 1 }$ 和 $w _ { 2 }$ 仅支配一个自由点，分别为 $u _ { 1 }$ 和 $u _ { 2 }$ ，如果实例 $\\boldsymbol { I } = ( G , S , D )$ 存在一个包含 $\\nu$ 但不包含 $w _ { 1 }$ 和 $w _ { 2 }$ 的最优解OPT，那么要么该最优解 $O P T$ 不包含 $u _ { 1 }$ 和 $u _ { 2 }$ ，要么存在另一个不包含 $\\nu$ 最优解 $O P T ^ { \\prime }$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "证明设 $O P T$ 为实例 $I = ( G , S \\cup \\{ \\nu \\} , D \\cup \\{ w _ { 1 } , w _ { 2 } \\} )$ 的最优解那么 $\\nu \\in O P T$ 和 $\\{ w _ { 1 } , w _ { 2 } \\} \\not \\in O P T$ 。反证 $O P T$ 不包含 $u _ { 1 }$ 和 $u _ { 2 }$ ，假设 $\\{ u _ { 1 } , u _ { 2 } \\} \\in O P T$ ，那么存在另外一个可行解 $O = O P T \\setminus \\{ \\nu \\}$ ，这与 $O P T$ 是最优解相矛盾，所以 $\\{ u _ { 1 } , u _ { 2 } \\} \\not \\in O P T$ 。假设 $u _ { 1 }$ 和 $u _ { 2 }$ 中有一个是属于 $O P T$ ，假定 $u _ { 1 } \\in O P T$ 且 $u _ { 2 } \\notin O P T$ ，由于最优解OPT会支配 $u _ { 2 }$ ，所以 $O P T$ 中至少包含一个 $u _ { 2 }$ 的除 $w _ { 2 }$ 之外的邻居 $x \\in N ( u _ { 2 } ) \\setminus \\{ w _ { 2 } \\}$ ，那么 $O P T = O ^ { \\prime } \\cup \\{ \\nu , x , u _ { 1 } \\}$ （ $O ^ { \\prime }$ 为某些合适的顶点集合)。由于 $\\nu$ 是候选点( $\\nu$ 已经被支配)， $w _ { 1 }$ 被 $u _ { 1 } \\in O P T$ 支配，那么将最优解 $O P T$ 中 $\\nu$ 换成 $u _ { 2 }$ ，得到另一个可行解$O P T ^ { \\prime } { = } O ^ { \\prime } \\cup \\{ u _ { 2 } , x , u _ { 1 } \\}$ ，又 $\\vert O P T \\vert { = } \\vert O P T \\vert$ ，那么 $O P T ^ { \\prime }$ 是一个不包含 $\\nu$ 的最优解，同理可以证 $u _ { 2 } \\in O P T$ 且 $u _ { 1 } \\notin O P T$ 的情况，所以可以抛弃 $\\nu$ ，见图2中的情况4。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "WW 表示已被选择的顶点O表示未被选择的顶点众情况3 情况4",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "定理3给出一个实例 $\\boldsymbol { I } = ( G , S , D )$ ，假设图 $G$ 存在一个候选点 $\\nu$ 仅支配两个自由点 $\\{ w _ { 1 } , w _ { 2 } \\}$ ，实例 $\\boldsymbol { I } = ( G , S , D )$ 存在一个最优解 $Y$ 使得如下成立：",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "a）如果 $w _ { i }$ 仅支配一个自由点 $u _ { i } \\notin N ( \\nu )$ ，即 $w _ { 1 }$ 支配 $u _ { 1 }$ 和 $w _ { 2 }$ 支配 $u _ { 2 }$ ，那么要么 $\\nu \\not \\in Y$ ，要么 $\\{ \\nu , w _ { 1 } \\} \\in Y$ ，要么 $\\{ \\nu , w _ { 2 } \\} \\in Y$ 且$w _ { 1 } \\not \\in Y$ ，要么 $\\nu \\in Y$ 且 $\\{ \\{ w _ { 1 } , w _ { 2 } \\} \\bigcup u _ { 1 } \\bigcup u _ { 2 } \\} \\not \\in Y$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "b）如果 $w _ { i }$ 至少支配两个自由点，设 $w _ { i }$ 支配的自由点集合为 $U _ { i } = \\{ u _ { i , 1 } , u _ { i , 2 } , . . . , u _ { i , k } \\} = N ( w _ { i } ) \\bigcap A \\setminus N [ \\nu ]$ ，其中 $k \\geq 2$ ，那么要么$\\nu \\not \\in Y$ ，要么 $\\{ \\nu , w _ { 1 } \\} \\in Y$ ，要么 $\\{ \\nu , w _ { 2 } \\} \\in Y$ 且 $w _ { 1 } \\not \\in Y$ ，要么 $\\nu \\in Y$ 且 $\\{ \\{ w _ { 1 } , w _ { 2 } \\} \\cup U _ { 1 } \\} \\not \\in Y$ ，要么 $\\nu \\in Y$ 且 $\\{ \\{ w _ { 1 } , w _ { 2 } \\} \\cup U _ { 2 } \\} \\not \\in Y$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "证明a）设 $Y ^ { \\prime }$ 为一个问题实例的最优解，假设 $Y ^ { \\prime }$ 包含顶点 $\\nu$ ，否则a)直接成立。假设 $w _ { 1 }$ 和 $w _ { 2 }$ 相邻，根据性质4可知，这种情况不会发生。那么，考虑 $w _ { 1 }$ 和 $w _ { 2 }$ 不相邻情况。假设 $w _ { 1 }$ 和$w _ { 2 }$ 共同支配了一个自由点 $u$ ，那么在 $Y ^ { \\prime }$ 中将 $\\nu$ 替换成 $u$ ，得到一个不包含 $\\nu$ 的可行解 $Y \"$ ，又 $\\big | Y ^ { \\boldsymbol { \\mathfrak { \\ \" } } } \\big | { \\leq } \\big | Y ^ { \\boldsymbol { \\prime } } \\big |$ ，所以Y\"是最优解。由于在抛弃 $\\nu$ 的这个分支 $( G \\backslash \\{ \\nu \\} , S , D \\cup \\{ \\nu \\} )$ 里已经考虑了该情况，所以 $w _ { 1 }$ 和 $w _ { 2 }$ 共同支配一个自由点的这种情况可以不用考虑。那么考虑 $w _ { 1 }$ 和 $w _ { 2 }$ 分别支配不同自由点 $u _ { 1 }$ 和 $u _ { 2 }$ 时的情况，如果 $\\{ w _ { 1 } , w _ { 2 } \\}$ 都不在 $Y ^ { \\prime }$ 中，根据性质8可知，要么最优解同时不包含 $u _ { 1 }$ 和 $u _ { 2 }$ ，要么存在另一个不包含 $\\nu$ 的最优解，从而 a)成立。如果 $w _ { 1 }$ 和 $w _ { 2 }$ 都在 $Y ^ { \\prime }$ 中，存在一个可行解 $Y ^ { \\ \" } { = } Y \\backslash \\{ \\nu \\}$ ，这与 $Y ^ { \\prime }$ 是最优解相矛盾，所以 $w _ { 1 }$ 和 $w _ { 2 }$ 不可能同时在 $Y ^ { \\prime }$ 中。如果 $w _ { 1 }$ 在 $Y ^ { \\prime }$ 中，a）直接成立。如果 $w _ { 2 }$ 在 $Y ^ { \\prime }$ 中，必然抛弃 $w _ { 1 }$ ，a）也成立。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "b）设 $Y ^ { \\prime }$ 为一个问题实例的最优解，假设Y'包含顶点 $\\nu$ ，否则b）直接成立。假设 $w _ { 1 }$ 和 $w _ { 2 }$ 相邻，那么在 $Y ^ { \\prime }$ 中将 $\\nu$ 替换成$w _ { 1 }$ ，得到一个不包含 $\\nu$ 的可行解 $Y \"$ ，又 $\\big | Y ^ { \\prime \\prime } \\big | { \\leq } \\big | Y ^ { \\prime } \\big |$ ，所以 $Y \"$ 是最优解。同样由于在抛弃 $\\nu$ 的这个分支 $( G \\backslash \\{ \\nu \\} , S , D \\cup \\{ \\nu \\} )$ 里已经考虑了该情况，所以 $w _ { 1 }$ 和 $w _ { 2 }$ 相邻这种情况可以不用考虑。那么，考虑 $w _ { 1 }$ 和 $w _ { 2 }$ 不相邻情况。假设 $w _ { 1 }$ 和 $w _ { 2 }$ 共同支配了一个自由点 $u$ ，那么在 $Y ^ { \\prime }$ 中将 $\\nu$ 替换成 $u$ ，得到一个不包含 $\\nu$ 的可行解 $Y \"$ 。同样，这种情况不用考虑。那么考虑 $w _ { 1 }$ 和 $w _ { 2 }$ 支配的自由点各不相同并且至少支配两个自由点时情况，设 $w _ { i }$ 支配的自由点集合为 $U _ { i } = \\{ u _ { i , 1 } , u _ { i , 2 } , . . . , u _ { i , k } \\} = N ( w _ { i } ) \\bigcap A \\backslash N [ \\nu ]$ 。如果$\\{ w _ { 1 } , w _ { 2 } \\}$ 都不在 $Y ^ { \\prime }$ 中，根据性质7可知，或者将 $U _ { 1 }$ 加入 $D$ 中，或者将 $U _ { 2 }$ 加入 $D$ 中，从而b）成立。如果 $w _ { 1 }$ 和 $w _ { 2 }$ 都在 $Y ^ { \\prime }$ 中，存在一个可行解 $Y ^ { \\prime \\prime } { = } Y \\backslash \\{ \\nu \\}$ ，这与 $Y ^ { \\prime }$ 是最优解相矛盾，所以$w _ { 1 }$ 和 $w _ { 2 }$ 不可能同时在 $Y ^ { \\prime }$ 中。如果 $w _ { 1 }$ 在 $Y ^ { \\prime }$ 中，b）直接成立。如果 $w _ { 2 }$ 在 $Y ^ { \\prime }$ 中，必然抛弃 $w _ { 1 }$ ，b）也成立。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "综上所述，定理3成立。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "根据定理3对图进行约简后，可以很容易得到，如果图中存在一个候选点 $\\nu$ ，那么 $\\nu$ 至少与三个自由点相邻。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "2.3算法设计",
        "text_level": 1,
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "基于以上的定理和性质，下面进行算法的详细设计，其主要步骤参见算法1。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "算法1．算法 $M C D ( G , S , D )$ ",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "输入：一个无向图 $G = ( V , E )$ 和 $G$ 的两个顶点子集",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "$S , D \\subseteq V$ ，其中 $S { = } \\{ \\nu _ { 1 } , \\nu _ { 2 } \\left| \\nu _ { 1 } \\nu _ { 2 } \\in E \\right\\}$ 且 $G [ S ]$ 为连通图。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "输出：图 $G$ 中满足 $S \\subseteq Y$ 的最小连通支配集 $Y$ 。 ",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "1.如果 $G [ S ]$ 不为连通图，则停止算法，返回 $\\phi$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "2.否则如果 $\\scriptstyle A = \\phi$ 且 $G [ S ]$ 为连通图，则返回S作为解。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "3．否则如果 $A \\neq \\phi$ ，且不存在任何的候选点，则返回 $\\phi$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "4.否则如果图中存在一个候选点 $\\nu$ 是必选点，则返回$M C D ( G , S \\cup \\{ \\nu \\} , D )$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "5.否则如果图中存在两个候选点 $\\nu$ 和 $w \\left( \\nu \\right.$ 和 $w$ 都不是必选点)，且 $N ( \\nu ) \\bigcap F \\subseteq N ( w ) \\bigcap F$ ，则返回 $M C D ( G \\setminus \\nu , S , D \\cup \\{ \\nu \\} )$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "6.否则如果图中存在一个可用点 $\\nu$ 不支配任何的自由点，即顶点 $\\nu$ 的所有邻居全部都被支配，则返回$M C D ( G \\setminus \\nu , S , D \\cup \\{ \\nu \\} )$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "7.否则如果图中存在一个候选点 $\\nu$ 支配一个可用点 $w$ ，选择顶点 $\\mathbf { \\sigma } _ { \\nu }$ 后， $w$ 不支配任何自由点，则返回$M C D ( G \\setminus \\nu , S , D \\cup \\{ \\nu \\} )$ 和 $M C D ( G \\setminus w , S \\bigcup \\{ \\nu \\} , D \\bigcup \\{ w \\} )$ 中的较大解。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "8.否则如果当前图中存在一个候选点 $\\mathbf { \\Psi } _ { \\nu } \\mid \\mathbf { \\Psi } _ { \\nu } \\mid \\mathbf { \\Psi } _ { \\nu }$ 仅支配一个自由点 $w$ ，而 $w$ 也仅支配一个自由点 $u \\not \\in N ( \\nu )$ ，则返回$M C D ( G \\setminus \\nu , S , D \\cup \\{ \\nu \\} )$ 和 $M C D ( G , S \\bigcup \\{ \\nu , w \\} , D )$ 中较大的解。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "9.否则如果当前图中存在一个候选点 $\\nu$ ， $\\nu$ 仅支配一个自由点 $w$ ， $w$ 至少支配两个自由点，设 $w$ 支配的自由点集合为$U { = } \\{ u _ { 1 } , u _ { 2 } , . . . , u _ { k } \\} { = } N ( w ) \\cap A \\setminus N [ \\nu ]$ ，其中 $k \\geq 2$ ，则返回$M C D ( G \\backslash \\nu , S , D \\bigcup \\{ \\nu \\} ) \\qquad , \\qquad M C D ( G , S \\bigcup \\{ \\nu , w \\} , D )$ 和$M C D ( G \\setminus \\{ w , U \\} , S \\bigcup \\{ \\nu \\} , D \\bigcup \\{ w , U \\} )$ 中较大的解。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "10.否则如果当前图中存在一个候选点 $\\nu$ ， $\\nu$ 仅支配两个自由点 $w _ { 1 }$ 和 $w _ { 2 }$ ， $w _ { 1 }$ 和 $w _ { 2 }$ 仅支配一个自由点分别为 $u _ { 1 }$ 和 $u _ { 2 }$ ，其中 $\\{ u _ { 1 } , u _ { 2 } \\} \\not \\in N ( \\nu )$ ，则返回 $M C D ( G \\setminus \\nu , S , D \\cup \\{ \\nu \\} )$ ，$M C D ( G , S \\cup \\{ \\nu , w _ { 1 } \\} , D )$ ， $M C D ( G \\setminus \\{ w _ { 1 } \\} , S \\cup \\{ \\nu , w _ { 2 } \\} , D \\cup \\{ w _ { 1 } \\} )$ ，$M C D ( G \\backslash \\{ w _ { 1 } , w _ { 2 } , u _ { 1 } , u _ { 2 } \\} , S \\cup \\{ \\nu \\} , D \\cup \\{ w _ { 1 } , w _ { 2 } , u _ { 1 } , u _ { 2 } \\} )$ 中较大的解。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "11.否则如果当前图中存在一个候选点 $\\boldsymbol \\nu _ { \\mathrm { ~ , ~ } \\nu }$ 支配两个自由点 $w _ { 1 }$ 和 $w _ { 2 }$ ， $w _ { 1 }$ 和 $w _ { 2 }$ 至少支配了两个自由点，设 $w _ { i }$ 支配的自由点集合为 $U _ { i } = \\{ u _ { i , 1 } , u _ { i , 2 } , . . . , u _ { i , k } \\} = N ( w _ { i } ) \\bigcap A \\setminus N [ \\nu ]$ ，其中 $k \\geq 2$ ，则返回 $M C D ( G \\setminus \\nu , S , D \\bigcup \\{ \\nu \\} ) \\qquad , \\qquad M C D ( G , S \\bigcup \\{ \\nu , w _ { 1 } \\} , D )$ ，$M C D ( G \\setminus \\{ w _ { 1 } \\} , S \\bigcup \\{ \\nu , w _ { 2 } \\} , D \\bigcup \\{ w _ { 1 } \\} )$ ，$M C D ( G \\setminus \\{ w _ { 1 } , w _ { 2 } , U _ { 1 } \\} , S \\cup \\{ \\nu \\} , D \\cup \\{ w _ { 1 } , w _ { 2 } \\} \\cup U _ { 1 } )$ 和$M C D ( G \\backslash \\{ w _ { 1 } , w _ { 2 } , U _ { 2 } \\} , S \\cup \\{ \\nu \\} , D \\cup \\{ w _ { 1 } , w _ { 2 } \\} \\cup U _ { 2 } )$ 中较大的解。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "12.否则当前图中存在一个候选点 $\\nu$ ，且 $\\nu$ 至少有三个自由点邻居时，则返回 $M C D ( G \\setminus \\nu , S , D \\cup \\{ \\nu \\} )$ 和$M C D ( G , S \\cup \\{ \\nu \\} , D )$ 中较大的解。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "文中用 $M C D ( G , S , D )$ 表示算法，输入部分为一个带约束的最小连通支配集问题的实例，包括一个无向连通图$G = ( V , E )$ 和 $G$ 的两个顶点子集 $S , D \\subseteq V$ ，其中导出子图$G [ S ]$ 为连通图。算法开始时，设 $s$ 中包含图中任意一条边的两个顶点 $\\nu _ { 1 }$ 和 $\\nu _ { 2 }$ ， $D$ 为空集，即 $M C D ( G , \\{ \\nu _ { 1 } , \\nu _ { 2 } \\} , \\phi )$ 。算法输出的是一个包含 $s$ 中所有顶点的最小连通支配集 $Y$ 。为了求出最小连通支配集，该算法需要执行 $O ( n ^ { 2 } )$ 次。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "则停止算法，返回 $\\phi$ ,这一步显然正确。第2步当 $A = \\phi$ 且 $G [ S ]$ 为连通图时，返回S作为解，这一步显然正确。第3步当 $A$ 不为空集但不存在任何的候选点，返回空集作为问题解，这一步也显然正确。第4步主要是将必选点加入S中，这一步的正确性由性质1给出。第5步当存在两个候选点 $\\nu$ 和 $u$ ，如果 $\\nu$ 所支配自由点全部被 $u$ 所支配那么删除 $\\nu$ ，这一步的正确性由性质2给出。第6步从图中删除一些不支配任何自由点的可用点，该步的正确性由性质3给出。第7步则是考虑存在一个候选点$\\nu$ 支配另一个可用点 $w$ ，当选择 $\\nu$ 后， $w$ 不支配任何自由点的情况。算法分为两个分支，第一个分支将 $\\nu$ 从图中删除，第二分支则是将 $\\nu$ 加入 $s$ 中并且将 $w$ 删除。其正确性由性质4给出。第8步则是考虑存在一个候选点 $\\nu$ 仅支配一个自由点 $w$ ， $w$ 也仅支配一个自由点 $u \\not \\in N ( \\nu )$ 时的情况。算法分为两个分支，第一个分支将 $\\nu$ 从图中删除，第二个分支将 $\\nu$ 和 $w$ 加入 $s$ 中，其正确性由定理2给出。在第9步则是考虑存在一个候选点 $\\nu$ 仅支配一个自由点 $w$ ， $w$ 至少支配两个自由点时的情况，设 $w$ 支配的自由点集合为 $U { = } \\{ u _ { 1 } , u _ { 2 } , . . . , u _ { k } \\} { = } N ( w ) \\cap A \\setminus N [ \\nu ]$ ，其中 $k \\geq 2$ ，算法分为三个分支，第一个分支将 $\\nu$ 从图中删除，第二个分支将 $\\nu$ 和 $w$ 加入 $s$ 中，第三个分支将 $\\nu$ 加入 $s$ 中同时删除（204号 $\\{ w , U \\}$ ，其正确性由定理2给出。第10步和第11步则是考虑存在一个候选点 $\\nu$ 支配两个自由点 $w _ { 1 }$ 和 $w _ { 2 }$ 的情况。第10步中，$w _ { 1 }$ 和 $w _ { 2 }$ 分别仅支配一个自由点 $u _ { 1 }$ 和 $u _ { 2 }$ ，算法分为四个分支，第一个分支将 $\\nu$ 从图中删除，第二个分支将 $\\nu$ 和 $w _ { 1 }$ 加入 $s$ 中，第三个分支将 $\\nu$ 和 $w _ { 2 }$ 加入 $s$ 中同时删除 $w _ { 1 }$ ，第四个分支将将$\\nu$ 加入 $s$ 中同时删除 $\\{ w _ { 1 } , w _ { 2 } , u _ { 1 } , u _ { 2 } \\}$ ，其正确性由定理3 给出。第11步中， $w _ { 1 }$ 和 $w _ { 2 }$ 至少支配两个自由点，设 $w _ { i }$ 支配的自由点集合为 $U _ { i } = \\{ u _ { i , 1 } , u _ { i , 2 } , . . . , u _ { i , k } \\} = N ( w _ { i } ) \\bigcap A \\backslash N [ \\nu ]$ ，其中 $k \\geq 2$ ，算法分为五个分支，第一个分支将 $\\nu$ 从图中删除，第二个分支将 $\\nu$ 和 $w _ { 1 }$ 加入 $s$ 中，第三个分支将 $\\nu$ 和 $w _ { 2 }$ 加入 $s$ 中同时删除 $w _ { 1 }$ ，第四个分支将 $\\nu$ 加入S中同时删除 $\\{ w _ { 1 } , w _ { 2 } , U _ { 1 } \\}$ ，第五个分支将$\\nu$ 加入S中同时删除 $\\{ w _ { 1 } , w _ { 2 } , U _ { 2 } \\}$ ，其正确性由定理3给出。第12 步则是做简单的分支，要么删除这个候选点，要么将其放入S中,这一步显然正确。可以看出,只要在图中 $A = V \\setminus ( S \\cup D )$ （204号不为空集，3至12 步中至少有一步可以执行，而当 $A = \\phi$ 且$G [ S ]$ 为连通时，执行第2步找到解集，当 $G [ S ]$ 不连通时，执行1步停止算法。由以上的分析可以得到该算法的正确性，以下则是算法运行时间的分析。",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "3 基于测量治之的算法运行时间分析 ",
        "text_level": 1,
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "以上是采用分支搜索算法设计的算法，这种算法包含约简和分支这两种操作。根据以上的算法可知，算法的第1,2,3,4,5和6步只进行了约简操作，第7,8.9,10,11和12步进行了分支操作。由于约简操作不会指数级的增加算法的运行时间，所以下面仅对算法的分支操作进行分析。",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "采用测量治之方法对算法的运行时间复杂度进行分析时，首先需要确定衡量问题大小的度量，然后根据设定的度量为算法的所有分支操作设计递归关系式。对于带约束的最小连通支配集问题的一个实例 $( G , S , D )$ ，定义衡量问题大小的度量为：",
        "page_idx": 5
    },
    {
        "type": "equation",
        "text": "$$\n\\mu ( G , S , D ) = \\alpha { \\big | } N ( S ) { \\big | } + { \\big | } V \\setminus ( S \\bigcup D \\bigcup N ( S ) ) { \\big | } ,\n$$",
        "text_format": "latex",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "其中 $0 < \\alpha < 1$ 是一个实数， $\\alpha$ 的值最后会根据所有分支操作列出的递归关系式计算出来，其具体值会在后面给出。根据度量的设定可知，集合 $s$ 和 $D$ 中的顶点权重设为0，候选集 $C$ 中的顶点权重设为 $\\alpha$ ，其余的顶点权重设为1，然后将图中所有顶点的权重之和 $\\mu ( G , S , D )$ 作为度量。显然，在算法执行的过程中，度量 $\\mu ( G , S , D )$ 的值在任何时候都不会大于图中的顶点数。",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "下面分析在设定的度量下各分支操作产生的递归关系式，文中用 $C ( \\mu )$ 表示算法在度量为 $\\mu$ 的问题实例上产生的搜索树大小的上界。",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "第7步在这一步中第一个分支删除候选点 $\\nu$ ，度量减少$\\alpha$ 。第二个分支将 $\\nu$ 加入 $s$ 中并且将 $w$ 删除，度量减少 $\\alpha { + } l$ ，又 $w$ 至少支配一个自由点，且该自由点同时也被 $\\nu$ 支配，当将$\\nu$ 加入 $s$ 后，其所支配的自由点变成候选点，度量至少减少$_ { { I - } \\alpha }$ ，所以第二分支至少减少2。这一步可以得到如下递归关系式",
        "page_idx": 5
    },
    {
        "type": "equation",
        "text": "$$\nC ( \\mu ) \\leq C ( \\mu - \\alpha ) + C ( \\mu - 2 ) .\n$$",
        "text_format": "latex",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "第8步在这一步中第一个分支删除候选点 $\\nu$ ，度量减少$\\alpha$ 。第二个分支将 $\\nu$ 加入 $s$ 中并且也将 $w$ 加入解中，度量减少$1 { + } \\alpha$ ， $w$ 的邻居 $u$ 变成候选点，度量减少 $_ { 1 - \\alpha }$ ，这样第二个分支减少 $\\scriptstyle 1 + \\alpha + I - \\alpha = 2$ 。这一步可以得到如下递归关系式",
        "page_idx": 5
    },
    {
        "type": "equation",
        "text": "$$\nC ( \\mu ) \\leq C ( \\mu - \\alpha ) + C ( \\mu - 2 ) .\n$$",
        "text_format": "latex",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "第9步在这一步中第一个分支删除候选点 $\\nu$ ，度量减少$\\alpha$ 。第二个分支将 $\\nu$ 加入 $s$ 中，并且将 $w$ 也加入 $s$ 中，由于 $w$ 至少支配两个自由点，当把 $w$ 加入 $s$ 后， $w$ 所支配的自由点变成了候选点，这样第二个分支的度量至少减少$\\alpha + 1 + 2 ( 1 - \\alpha ) = 3 - \\alpha$ 。第三个分支，将 $\\nu$ 加入S的目的是为了支配 $w$ ，所以将 $\\nu$ 加入S后，将 $w$ 删除，同时删除 $w$ 的自由点邻居，这样度量至少减少 $3 { + } \\alpha$ 。这一步可以得到如下递归关系式",
        "page_idx": 5
    },
    {
        "type": "equation",
        "text": "$$\nC ( \\mu ) \\le C ( \\mu - \\alpha ) + C ( \\mu - ( 3 - \\alpha ) ) + C ( \\mu - ( 3 + \\alpha ) ) .\n$$",
        "text_format": "latex",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "第 10 步在这一步中第一个分支删除候选点 $\\nu$ ，度量减少 $\\alpha$ 。第二个分支将 $\\nu$ 加入 $s$ ，其目的是为了连通 $w _ { 1 }$ ，所以将$\\nu$ 和 $w _ { 1 }$ 加入 $s$ ，度量至少减少 $_ { 3 - \\alpha }$ 。第三个分支将 $\\nu$ 加入 $s$ ，其目的是为了连通 $w _ { 2 }$ ，所以将 $\\nu$ 和 $w _ { 2 }$ 加入 $s$ ，同时删除 $w _ { 1 }$ ，度量至少减少3。第四个分支将 $\\nu$ 加入 $s$ ，其目的是为了支配$w _ { 1 }$ 和 $w _ { 2 }$ ，所以将 $\\nu$ 加入 $s$ ，同时删除 $\\{ w _ { 1 } , w _ { 2 } , u _ { 1 } , u _ { 2 } \\}$ ，度量至少减少 $_ { 4 + \\alpha }$ 。这一步可以得到如下递归关系式",
        "page_idx": 5
    },
    {
        "type": "equation",
        "text": "$$\nC ( \\mu ) { \\le } C ( \\mu - \\alpha ) + C ( \\mu - ( 3 - \\alpha ) )\n$$",
        "text_format": "latex",
        "page_idx": 5
    },
    {
        "type": "equation",
        "text": "$$\n+ C ( \\mu - 3 ) + C ( \\mu - ( 4 + \\alpha ) ) .\n$$",
        "text_format": "latex",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "第 11步在在这一步中第一个分支删除候选点 $\\nu$ ，度量减少 $\\alpha$ 。第二个分支将 $\\nu$ 加入 $s$ ，其目的是为了连通 $w _ { 1 }$ ，所以将 $\\nu$ 和 $w _ { 1 }$ 加入S，度量至少减少 $4 - 2 \\alpha$ 。第三个分支将 $\\nu$ 加入$s$ ，其目的是为了连通 $w _ { 2 }$ ，所以将 $\\nu$ 和 $w _ { 2 }$ 加入S，同时删除$w _ { 1 }$ ，度量至少减少 $_ 4 - \\alpha$ 。第四个分支将 $\\nu$ 加入 $s$ ，其目的是为了支配 $w _ { 1 }$ 和 $w _ { 2 }$ ，所以将 $\\nu$ 加入 $s$ ，同时删除 $w _ { 1 }$ 、 $w _ { 2 }$ 以及 $U _ { 1 }$ ，度量至少减少 $4 + \\alpha$ 。第五个分支将 $\\nu$ 加入 $s$ ，其目的是为了支配 $w _ { 1 }$ 和 $w _ { 2 }$ ，所以将 $\\nu$ 加入 $s$ ，同时删除 $w _ { 1 } , w _ { 2 }$ 以及 $U _ { 2 }$ ，度量至少减少 $4 + \\alpha$ 。这一步可以得到如下递归关系式",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 6
    },
    {
        "type": "equation",
        "text": "$$\nC ( \\mu ) \\le C ( \\mu - \\alpha ) + C ( \\mu - ( 4 - 2 \\alpha ) ) + C ( \\mu - ( 4 - \\alpha ) )\n$$",
        "text_format": "latex",
        "page_idx": 6
    },
    {
        "type": "equation",
        "text": "$$\n+ C ( \\mu - ( 4 + \\alpha ) ) + C ( \\mu - ( 4 + \\alpha ) ) .\n$$",
        "text_format": "latex",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "第 12 步这一步对 $\\nu$ 进行简单分支，要么将 $\\nu$ 加入 $s$ 中要么删除。由于此时至少支配3个自由点，当 $\\nu$ 加入 $s$ 后，至少3个自由点变成候选点，其度量至少减少$\\alpha + 3 ( 1 - \\alpha ) = 3 - 2 \\alpha$ 。这一步可以得到如下递归关系式",
        "page_idx": 6
    },
    {
        "type": "equation",
        "text": "$$\nC ( \\mu ) { \\le } C ( \\mu - \\alpha ) + C ( \\mu - ( 3 - 2 \\alpha ) ) .\n$$",
        "text_format": "latex",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "将上述所有递归关系式作为约束条件组成一个拟凸规划的约束条件，目标是使以上递归关系式中最大分支因子最小，其中 $\\alpha$ 为变量。利用[25]中介绍的方法对这个拟凸规划求解得到，当 $\\alpha = 0 . 8 6 4 4$ 时，上述递归关系的最大分子因子为1.93，因此该算法运行时间上界为 $O ^ { * } ( 1 . 9 3 ^ { \\mu } )$ 。由于在初始图上 $\\mu \\leq n$ ，因此带约束的最小连通支配集问题可以在 $O ^ { * } ( 1 . 9 3 ^ { n } )$ 时间内被解决，得到如下定理。",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "定理4最小连通支配集问题可以在 $O ^ { * } ( 1 . 9 3 ^ { n } )$ 时间内解决。",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "4 结束语",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "针对无向图中最小连通支配集问题，本文采用分支搜索方法和测量治之方法分析和设计了一个运行时间为 $O ^ { * } ( 1 . 9 3 ^ { n } )$ 的精确算法。文中首先分析该问题的一些特性，设计了一些约简规则简化问题实例，并在此基础上证明了一些重要的定理，最终设计出一个基于分支搜索的递归算法。文中算法的基本思想是保持解的连通性，其核心思想是在处理候选点时，对其加入解的作用进行区分对待，最后利用测量治之方法对算法的运行时间进行分析。对于连通支配集问题在一些实际问题中的应用时，文中的一些性质和定理可以在一定程度上降低原问题的求解规模和难度，因此可以将其同启发式算法相结合对该问题进行求解，达到加快求解该问题的速度和提高求解效果的目的。文中使用的测量治之方法是一种非常重要的算法分析方法，它改进了许多重要NP难问题的精确算法的运行时间界，对于更多的NP难问题该方法在其精确算法中的应用正在进一步拓展中。",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "参考文献：",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "[1]Cook SA.The complexity of theorem-proving procedures [C]//Proc of the 3rd ACMSymposium on the Theory of Computing.New York:ACMPress, 1971:151-158. ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "[2]Impagliazzo R,Paturi R, Zane F.Which problems have strongly exponential complexity?[J]. Journal of Computer and System Sciences,2001,63 (4): 512–530, 2001.   \n[3]路纲，周明天，唐勇，等.任意图支配集精确算法回顾[J].计算机学 报,2010,33(6):1073-1087.(Lu Gang,Zhou Mingtian,Tang Yong,et al.A survey on exact algorithms fordonminating set related problems in arbitrary graphs [J]. Chinese Journal of Computers,2010,33(6):1073-1087.   \n[4] Held M, Karp R M. A dynamic programming approach to sequencing problems [J]. Journal of SIAM,1962,10(1):196-210.   \n[5]Tarjan R,Trojanowski A.Finding a maximum independent set [J]. SIAM Journal on Computing,1977,6 (3): 537-546.   \n[6]Robson JM.Algorithms for maximum independent sets [J]. Journal of Algorithms,1986,7(3): 425-440.   \n[7]Mingyu Xiao, Nagamochi H. Exact algorithms for maximum independent set [C]// Proc of the 24th International Symposium on Algorithms and Computation.Berlin: Springer Publishing Company,2013: 328-338.   \n[8] Claude B.The theory of graphs and its applications [J].Bulletin of Mathematical Biophysics,1962,24 (4): 441-443.   \n[9]Ore O.Theory of Graphs [M]. Providence: American Mathematical Society, 1962.   \n[10] Garey MR,Johnson D S.Computers and intractability: a guide to the theory of NP-completeness[M]. New York: W. H. Freeman,1979.   \n[11] FominFV, Kratsch D,Woeginger GJ. Exact (exponential) algorithms for the dominating set problem [C]// Proc of the 30th Workshop on Graph Theoretic Concepts in Computer Science.Berlin: Springer,2004: 245-256.   \n[12]RijJVodenderHLExactalgorithfordoatig[] Discrete Applied Mathematics,2011,159 (17): 2147-2164.   \n[13] Yannakakis M, Gavril F.Edge dominating sets in graphs [J]. SIAM Journal on Applied Mathematics,1980,38 (3): 364-372.   \n[14]SchiermeerIEficixponentialtiefordomiatio-teblem [J].Discrete Applied Mathematics,2008,156 (17): 3291-3297.   \n[15] Xiao M,NagamochiH.Arefiedexact algorithmforedgedominatingset [J].Theoretical Computer Science,2014,560: 207-216.   \n[16] Fomin F V, Grandoni F,Kratsch D. Solving connected dominating set faster than[J].Algorithmica,2008,52 (2):153-166.   \n[17] Ugurlu O,Tanir D, Nuri E.A beter heuristic for the minimum connected dominating set in ad hoc networks [C]// Proc of IEEE International Conferenceon Application of Informationand Communication Technologies. New York: IEEE,2017: 1-4.   \n[18] Baiou M,Barahona F.The dominating set polytope via facility location [M]. Berlin: Springer International Publishing,20l4: 38-49.   \n[19] Mohanty JP, Mandal C,Reade C,et al. Construction ofminimum connected dominating set in wireless sensor networks using pseudo dominating set [J] Ad Hoc Networks,2016,42 (C): 61-73.   \n[20]黄庆东，闫乔乔，孙晴．一种改进的ad hoc无线网络连通支配集生成方 法[J].电子科技大学学报,2017,46(6):819-824.(Huang Qingdong,Yan Qiaoqiao,Sun Qing.An improved formation method of connecteddominating set in Ad hoc wireless networks [J].Journal ofUniversity of Electronic Science and Technology of China,2017,46 (6): 819-824.)   \n[21] Touil S,Mahfoudhi,Laouamer L,et al.A novel scheme for selecting minimum connected dominating set in Ad hoc and WSNs [J].Research Journal of Applied Sciences,2017,12:409-415.   \n[22] Shukla S,Misra R,Agarwal A. Virtual coordinate system using dominating set for GPS-free adhoc networks [J].Annals of Telecommunications,2017, 72 (3-4): 1-10.   \n[23]FominFV,GrandoniF,Kratsch D.A measure & conquer approach for the analysis of exact algorithms [J].Journal of the ACM,2009,56(5):1-32.   \n[24]周晓清，肖鸣宇．无向图中子集反馈顶点集问题的精确算法[J]，计算 机学报，2018,41(3):493-505.(Zhou Xiaoqing,Xiao Mingyu. Exact Algorithms for the Subset Feedback Vertex Set Problem in Undirected Graphs [J].Chinese Journal of Computers,2018,41(3): 493-505.)   \n[25] Eppstein D.Quasiconvex analysis of multivariate recurrence equations for backtracking algorithms [J].ACM Trans on Algorithms,20o6,2(4):492- 509. ",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 7
    }
]