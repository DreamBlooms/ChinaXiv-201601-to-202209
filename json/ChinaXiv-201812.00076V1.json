[
    {
        "type": "text",
        "text": "一种轻量级的雾计算属性基外包加密算法",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "曾萍¹，钱进1²，穆成新³，高原¹，胡荣磊1(1．北京电子科技学院，北京 100000;2.西安电子科技大学 通信工程学院，西安 710000；3.空军哈尔滨飞行学院理论训练系，哈尔滨 150001)",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "摘要：基于属性的加密算法拥有灵活、细粒度、安全性高等特点，为减少属性基加密算法占用的资源，在安全数据访问控制的属性基加密算法的基础上提出了一种改进的属性基外包加密算法。改进算法将加密算法中的复杂双线性对计算外包给雾节点以减少用户的计算开销；同时通过简化系统参数，减少属性中心为属性生成的随机因子以缩短密文和密钥长度，降低了用户和雾节点的存储和通信开销。同时对提出的改进算法进行了安全性证明，证明了该改进算法是安全的。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "关键词：属性基加密；加密外包；雾计算；安全性证明；门限分割 中图分类号：TP309.7 doi: 10.19734/j.issn.1001-3695.2018.06.0556 ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Light weight atribute-based encryption outsourced algorithm for fog computing ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Zeng Ping1, Qian Jin1,²,Mu Chenxin³, Gao Yuan1, Hu Ronglei1 (1. Beijing Electronics Science&Technology Institute,Beijing0oo0,China;2.SchoolofCommunication&Engineering, Xidian University,Xian70o,China;3.Dept.ofTheoreticalTaining,People'sLiberationArmyAirForceHarbinFlight Academy,Harbin 150001,China) ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Abstract:Atribute-based encryptionalgorithmhas thecharacteristicsas flexibility,fine-grainedandhigh security.This paper introduces an improved atribute-based outsourced encryption algorithm based on secure data access control atribute-based encryption,to reduce theresources consumedby computation,which outsources thecomplex bilinear pairings in the encryption computing to the fog node toreduce the user's computation overhead.Bysimplifying the system parameters，wereduce therandom number generated byatributeauthority forevery atribute to shorten the length of ciphertext and thekey,as well as thestoragecostof thesystem.Andthe securityproofof theschemeis giveninthelastpart of this paper. ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Key words:atribute-based encryption; outsourcing encryption; fog computing;securityanalysis;threshold segmentation ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "0 引言",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "云计算是一种基于共享建立的新计算模式，用户将需要托管和分析的数据传输到云平台进行管理[1]。而雾计算作为对云计算的拓展，将计算迁移到靠近用户端的雾计算节点，有效节省了云平台的网络开销，避免了云平台的网络性能瓶颈[2]。但是这样会带来雾计算设备管理问题，雾计算节点由于部署在云平台的远端缺乏持续有效的管理，极易受到攻击；用户设备与雾节点之间缺乏有效的信任机制，此外雾节点还要接受来自多种异构设备的访问，大量的用户设备接入网络使得用户管理变得异常困难[3]。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "密文策略的属性基加密方案(ciphertext-policyattribute-basedencryption)通过对密文标定属性，规定访问者的访问策略，实现用户对数据的细粒度访问。虽然这种方案克服了用户访问过程中的粒度控制问题，但同时也带来了属性管理的问题。密钥生成中心根据用户的属性集生成相应的私钥，但如何隐藏私钥中带有用户属性集的特征，保证属性集信息不被泄露是一个问题。此外当用户更新、添加或是撤销属性时，密钥生成中心需要根据新的属性集更新密钥。如何保证改变的属性不被暴露，撤销的属性被彻底销毁以及如何保证密钥更新的前后向安全性都是目前急需解决的困难的问题。属性基加密方案最先在文献[4]中提出。为了克服该方案中访问不灵活的缺点，文献[5]中提出了密文策略的加密方案，将属性关联于密文，接收方根据密文规定的属性集判断自己能否进行解密。基于属性的签名(ABS)方案[6可以实现认证功能，但是不能实现安全通信。文献[7]在标准模型下证明了文献[6]中签名算法的安全性，但是不能应用于雾计算加解密外包的环境。文献[8]改进了签名算法使其可以运用于加解密外包环境下，但是不能保证数据的安全性。文献[9]提出了一种由分层的身份基加密方案演变而来的属性基加密方案，方案中使用了混合双系统加密，方案的灵活性大大加强，用户可以指定任意深度的访问策略，但是方案涉及多个乘法群上的双线性变换，计算量过大。文献[10]提出了一种属性与角色混合加密算法，兼有细粒度和访问灵活的特点，但是安全性有所下降。文献[11]提出了一种带有属性更新功能的外包加密方案。文献[12]提出了一种改进的属性基加密方案，通过减少乘法循环群上的计算次数来减少用户的计算开销，同时能够按照用户属性集的变化进行密文更新。文献[13]提出一种安全性更高的属性基加密方案，但是由于该方案为多认证中心方案，认证交互次数过多，不适合雾计算环境。文献[14]提出了一种适用于雾计算环境的加密方案，但由于该方案使用多认证中心，使得用户的通信开销过大，因此不适宜运用在移动设备上。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "本文主要工作为设计一种改进的适用于雾计算的属性基加密算法，简化系统参数，减少属性中心为属性生成的随机因子以缩短密文和密钥长度，降低了用户和雾节点的存储和通信开销。同时利用标准模型对提出的改进算法进行了安全性证明，证明了该改进算法是安全的。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "1 技术基础",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "a）双线性变换[15]为一种在乘法群上的映射。设有一大素数 $q$ ，定义 $G _ { 0 }$ 和 $G _ { 1 }$ 为两个阶为 $q$ 的乘法循环群，运行在群$G _ { 0 }$ 上的映射 $e : G _ { 0 } \\times G _ { 0 } \\to G _ { 1 }$ 满足以下三种性质时被称做双线性映射：",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "(a)双线性。对于任意的群 $G _ { 0 }$ 上的元素 $g , p , r \\in G _ { 0 }$ 和$a , b \\in Z _ { \\ q }$ 都有 $e ( g ^ { a } , p ^ { b } ) = e ( g , p ) ^ { a b }$ 和 $e ( g p , r ) = e ( g , r ) \\cdot e ( p , r )$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "(b)非退化性。当 $g$ 是 $G _ { 0 }$ 时， $e ( g , g )$ 是 $G _ { 1 }$ 的单位元，且 $\\boldsymbol { \\mathscr { e } }$ 不把 $G _ { 0 }$ 的所有元素对都映射到 $G _ { \\mathrm { { l } } }$ 的单位元。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "(c)可计算性。对于任意 $g , p \\in G$ 都有有效的算法计算$e ( g , p )$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "b)判定性双线性问题(DBDH)。假设存在 $q$ 阶循环群 $G _ { 0 }$ 和群上的元素 $p$ 以及运行在群上的双线性变换 $\\mathbf { \\Psi } _ { e }$ ，随机选定整数 $a , b , c \\in Z _ { q }$ ，给定两个元组 $( p , p ^ { a } , p ^ { b } , p ^ { c } , e ( p , p ) ^ { a b c } )$ 和$( p , p ^ { a } , p ^ { b } , p ^ { c } , k )$ 其中 $k$ 是和 $e ( p , p ) ^ { a b c }$ 同分布的随机比特串，区分两个元组中哪一个是随机元组。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2 安全模型",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "本文采用标准模型证明加密方案的安全性。模型中假设云平台是安全的，利用挑战者和攻击者之间的博弈游戏描述模型，具体过程如下：",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "系统初始化：向系统 $s$ 输入公共参数params。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "查询阶段1：攻击者 $\\mathcal { A }$ 可以向系统提出任意属性集，系统运行KeyGen算法生成相应的私钥 $\\mathit { s K }$ 并返回给攻击者。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "挑战阶段：攻击者向系统提供两个等长的明文 $m _ { 0 }$ 和 $m _ { \\mathrm { 1 } }$ ，并向系统提出一个访问结构 $T _ { a }$ ，该结构不能在查询阶段1被查询过且不能是询问阶段任何结构的子树。系统随机选取一个比特 $b \\in \\{ 0 , 1 \\}$ ，并生成结构 $T _ { a }$ 的私钥，对明文 $m _ { b }$ 进行加密得到密文 $C _ { b }$ 并返回给攻击者。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "查询阶段2：攻击者继续向系统提出询问，该阶段不能进行对结构 $T _ { a }$ 和以 $T _ { a }$ 为子树的询问。系统继续向攻击者提供查询信息。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "猜测阶段：攻击者根据查询结果猜测挑战阶段获得的密文是 $m _ { 0 }$ 和 $m _ { \\mathrm { { l } } }$ 中哪一个的密文，攻击者输出相应的比特$b ^ { \\prime } \\in \\{ 0 , 1 \\}$ ，攻击者的优势定义为 $A d \\nu = \\left| \\operatorname* { P r } \\left[ b = b ^ { \\prime } \\right] - 1 / 2 \\right|$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "3 加密方案设计",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "3.1系统简介",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "如图1所示。本系统包含四个部分，即云平台、雾节点、数据拥有者和其他访问用户。云平台负责生成系统参数，决定系统的安全等级、承担属性中心的工作，同时还要调度雾计算节点的资源以及处理用户的接入认证请求，生成用户的密钥。雾节点负责与用户进行通信，传递用户的认证信息，代替用户完成数据的加密外包工作，确保数据只能被符合一定属性要求的用户进行解密。数据拥有者利用自己的私钥对明文进行用户加密，确保密文不会被非法用户解密。当访问用户提出数据访问请求时，首先检查密文是否可以被正确解密，若可以被正确解密，即指定雾节点进行外包解密，访问用户在收到雾节点的部分解密密文后进行用户解密，得到明文。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "3.2设计思想",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "为简化加密的复杂度并节省开销，可以将加解密计算外包给加雾节点。在保证安全性的前提下，为进一步简化外包给雾节点的加密解过程，通过减少雾节点加入到部分密文中的随机因子，可以将原有密文长度缩短一半。同时由雾节点指定部分密文中的秘密分量，保证了前向安全性。",
        "page_idx": 1
    },
    {
        "type": "image",
        "img_path": "images/9784678298a7e7be10be281d38f476489cc52ec33a0f1b563c2f1df72fdcd7a4.jpg",
        "img_caption": [
            "图1系统架构图",
            "Fig.1System architecture diagram "
        ],
        "img_footnote": [],
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "加密方案的设计流程如下：",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "a) SysSetup(k)：属性中心输入安全参数 $k$ ，产生系统参数params。算法生成 $q$ 阶乘法群 $G _ { 0 }$ 和 $G _ { \\imath }$ ，其中 $q$ 为一个大素数，同时生成双线性映射 $e : G _ { 0 } \\times G _ { 0 } \\to G _ { 1 }$ 和哈希函数 $H : \\{ 0 , 1 \\} ^ { * } \\to G _ { 0 }$ 。属性中心选取随机数 $\\alpha , \\beta \\in Z _ { q }$ ，计算云平台公钥 $\\boldsymbol { P } \\boldsymbol { K } _ { c } = \\boldsymbol { g } ^ { \\alpha }$ ，云平台主密钥为 $M S K _ { c } = \\alpha$ 。系统参数为params $= ( g , h , g ^ { \\alpha } , e , e ( h , g ) , H )$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "b) $A t t r S e t u p ( p a r a m s , A )$ ：属性中心获取系统参数后为每一个属性生成密钥分量，其中 $A$ 为属性集。假设 $A$ 中有 $N$ 个属性，则 $A$ 可以表示为 $\\{ a t t r _ { 1 } , a t t r _ { 2 } , . . . , a t t r _ { N } \\}$ ，其中的 $a t t r _ { i }$ 为某一属性，将所有属性看做是互不相同的比特串，对于所有属性计算 $\\lambda _ { 1 } = H \\left( a t t r _ { 1 } \\right)$ ， $\\lambda _ { 2 } = H \\left( a t t r _ { 2 } \\right) \\ldots \\lambda _ { N } = H \\left( a t t r _ { N } \\right)$ 。计算， $D _ { 1 } = \\lambda _ { 1 } ^ { \\alpha }$ ，$D _ { 2 } = { \\lambda _ { 2 } } ^ { \\alpha } \\dots D _ { N } = { \\lambda _ { N } } ^ { \\alpha }$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "c) $K e y G e n ( p a r a m s , A _ { i } )$ ：属性中心输入某一用户 $U _ { _ i }$ 的属性集$A _ { i }$ 和系统参数params，生成对应的密钥。假设属性集 $A _ { i }$ 为$\\{ U a _ { 1 } , U a _ { 2 } , . . . , U a _ { n } \\}$ ，其中 $U a _ { i }$ 为用户拥有的属性。属性中心为用户选取唯一的随机数 $\\omega \\in Z _ { q }$ ，计算用户密钥 $S K = g ^ { \\alpha ( \\beta + \\omega ) }$ 和外包密钥 $S K ^ { \\prime } = \\{ g ^ { \\omega } h ^ { \\varepsilon } , g ^ { \\varepsilon } , C _ { 0 } = P K ^ { \\omega } , C _ { j } = D _ { j } ^ { \\ o } \\} _ { j \\in A _ { i } }$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "d) $F o g E n c r y p t ( S K ^ { \\prime } , T _ { U } )$ ：雾节点收到加密外包密钥 $S K ^ { \\prime }$ 和用户的属性策略 $T _ { \\phantom { } _ { U } }$ 后选取随机数 $m \\in Z _ { q }$ 。雾节点将 $\\mid m$ 作为分割秘密数，根据用户的属性策略利用门线分割方法计算 $m$ 分割后的分量 $\\{ y _ { 1 } \\left( 0 \\right) , y _ { 2 } \\left( 0 \\right) , . . . , y _ { n } \\left( 0 \\right) \\}$ （204号 并计算$C T ^ { \\prime } = \\left\\{ g ^ { y _ { 1 } ( 0 ) } D _ { 1 } , g ^ { y _ { 2 } ( 0 ) } D _ { 2 } , . . . , g ^ { y _ { n } ( 0 ) } D _ { n } \\right\\}$ 和 $T = g ^ { \\alpha m } , h ^ { \\alpha m }$ 0",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "e $) U s e r E n c r y p t ( C _ { 0 } , C T ^ { \\prime } , T )$ ：用户获得 $C _ { 0 }$ ， $\\vert { C T ^ { \\prime } }$ 和 $T$ 之后进行用户加密,选取随机数 $t , D K \\in Z _ { q }$ ，计算 $T _ { 0 } = g ^ { \\alpha m } \\cdot g ^ { \\alpha t }$ ， $T _ { 1 } = h ^ { \\alpha m } \\cdot h ^ { \\alpha t }$ ，$g ^ { \\prime }$ 和 $D K \\cdot e \\left( g , g \\right) ^ { \\alpha \\beta t }$ ，利用 $D K$ 对明文进行对称加密。密文为$C T = \\left\\{ T _ { \\scriptscriptstyle 0 } , T _ { \\scriptscriptstyle 1 } , g ^ { \\prime } , D K \\cdot e \\left( g , g \\right) ^ { \\alpha \\beta t } , C T ^ { \\prime } , S E _ { _ { D K } } \\left( M \\right) \\right\\} _ { \\mathrm { ~ o ~ } }$ ",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "f)FogDecrypt:雾节点2接收到 $c T$ 后进行外包解密。雾节点2利用用户的外包密钥 $S K ^ { \\prime } = \\left\\{ g ^ { \\omega } h ^ { \\varepsilon } , g ^ { \\varepsilon } , C _ { 0 } = P K ^ { \\omega } , C _ { j } = { D _ { j } } ^ { \\omega } \\right\\} _ { j \\in A _ { i } }$ 计算",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nF _ { j } = \\frac { e \\big ( g ^ { y _ { j } ( 0 ) } D _ { j } , C _ { 0 } } { e \\big ( P K , C _ { j } } ^ { \\prime } \\big )  { { e \\big ( P K , C _ { j } } ^ { \\prime } \\big ) } = e \\big ( g , g \\big ) ^ { y _ { j } ( 0 ) \\alpha \\omega }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "从访问结构的叶子节点开始计算父节点的值：",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { l } { { \\displaystyle F = \\prod _ { x \\in c h i l d r e n } \\left( e \\left( g , g \\right) ^ { y _ { p a r e n t } \\left( i n d e x \\left( x \\right) \\right) \\alpha \\omega } \\right) ^ { p _ { p a r e n t } \\left( 0 \\right) } } } \\\\ { ~ = \\prod _ { x \\in c h i l d r e n } e \\left( g , g \\right) ^ { y _ { x } \\left( 0 \\right) \\alpha \\omega p _ { x } \\left( 0 \\right) } } \\\\ { ~ = e \\left( g , g \\right) ^ { y _ { p a r e n t } \\left( 0 \\right) \\alpha \\omega } } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "依此类推可以还原出 ${ { e } \\left( { g , g } \\right) ^ { m a \\omega ^ { \\prime } } }$ 。同时计算",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\frac { e \\left( g ^ { \\omega } h ^ { \\varepsilon } , g ^ { \\alpha ( m + t ) } \\right) } { e \\left( g ^ { \\varepsilon } , h ^ { \\alpha ( m + t ) } \\right) } = e \\left( g , g \\right) ^ { \\alpha \\omega ( m + t ) }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n{ \\frac { e \\left( g , g \\right) ^ { \\alpha \\omega \\left( m + t \\right) } } { e \\left( g , g \\right) ^ { \\alpha o m } } } = e \\left( g , g \\right) ^ { \\alpha \\omega t }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "g)UserDecrypt:用户计算对称密钥",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nD K = { \\frac { D K \\cdot e \\left( g , g \\right) ^ { \\alpha \\beta t } \\cdot e \\left( g , g \\right) ^ { \\alpha \\omega t } } { e \\left( g ^ { t } , g ^ { \\alpha \\left( \\beta + \\omega \\right) } \\right) } }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "最后解密密文 $D e c ( D K , S E _ { D K } ( M ) )$ 得到明文。  \n以上加解密过程如图2和3所示。",
        "page_idx": 2
    },
    {
        "type": "image",
        "img_path": "images/7c301649407a5270846fe04b3258eccf95a379c9f55c2e0b77266934b5b9538d.jpg",
        "img_caption": [
            "图2加密过程交互示意图"
        ],
        "img_footnote": [],
        "page_idx": 2
    },
    {
        "type": "image",
        "img_path": "images/1592c809f7f1f8828066758b078996dd771b7e2274e9977bdde4fb01b5ac08c0.jpg",
        "img_caption": [
            "Fig.2Schematic diagram of encryption process ",
            "图3解密过程交互示意图",
            "Fig.3Schematic diagram of decryption process "
        ],
        "img_footnote": [],
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "4 安全性证明",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "假设有一个攻击者 $\\mathcal { A }$ 能够以不可忽略的优势 $\\varepsilon$ 来攻破该系统，那么就存在一个算法 $_ { { \\boldsymbol { B } } }$ 可以调用 $\\mathcal { A }$ 来解决DBDH问题。假设系统一共有 $k _ { \\scriptscriptstyle N }$ 个属性结构。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "初始化：系统生成 $q$ 阶群 $G _ { 0 } , G _ { 1 }$ 和双线性映射$e : G _ { 0 } \\times G _ { 0 } \\to G _ { 1 }$ ，选取生成元 $g , h \\in G _ { 0 }$ 和随机数 $\\alpha \\in Z _ { q }$ 以及属性集 $A = \\left\\{ a t t r _ { 1 } , a t t r _ { 2 } , . . . , a t t r _ { N } \\right\\}$ 共 $N$ 个属性，其中 $N \\leq q$ ，计算$D _ { 1 } = H \\left( a t t r _ { 1 } \\right) ^ { \\alpha }$ ， $D _ { 2 } = H \\left( a t t r _ { 2 } \\right) ^ { \\alpha }$ ， $D _ { _ { N } } = H \\left( a t t r _ { _ { N } } \\right) ^ { \\alpha }$ 。挑战者 $\\boldsymbol { B }$ 选定自己要解决的DBDH问题 $( A = g ^ { a } , B = g ^ { b } , C = g ^ { c } , D = g ^ { a b c } )$ ，同时从 $A$ 中选取子集作为Corrupted属性集 $A _ { b } = \\{ a _ { 1 } , a _ { 2 } , . . . , a _ { M } \\}$ ，其中 $a _ { i }$ 为某一属性， $A _ { b }$ 中有 $\\mathbf { \\Omega } _ { M }$ 个属性。挑战者计算 $B _ { 1 } = H ( a _ { 1 } ) ^ { a }$ ，$B _ { 2 } = H ( a _ { 2 } ) ^ { a }$ $B _ { \\scriptscriptstyle M } = H ( a _ { \\scriptscriptstyle M } ) ^ { a }$ 。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "询问阶段1：攻击者 $\\mathcal { A }$ 向挑战者 $\\boldsymbol { { \\it B } }$ 询问一个属性结构 $T _ { a }$ ，结构的属性集为 $A _ { a } = \\{ a t t r _ { 1 } , a t t r _ { 2 } , . . . , a t t r _ { m } \\}$ 。挑战者建立一张表Table记录属性结构 $T _ { a }$ 以及相应的私钥 $\\mathit { s K }$ ，该表对 $\\boldsymbol { { \\it B } }$ 是完全透明的， $\\boldsymbol { { \\it B } }$ 可以随时查询该表。挑战者根据攻击者的询问内容分情况进行处理：",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "情况1如果 $A _ { a } \\cap A _ { b } = \\emptyset$ ，挑战者选取随机数 $\\omega , \\varepsilon \\in Z _ { q }$ ，计算密钥 $S K = g ^ { \\alpha ( \\beta + \\omega ) }$ 和 $S K ^ { \\prime } = \\left\\{ g ^ { \\omega } h ^ { \\varepsilon } , g ^ { \\varepsilon } , C _ { 0 } = P K ^ { \\omega } , C _ { j } = { D _ { j } } ^ { \\omega } \\right\\} _ { j \\in A _ { a } }$ ，将密钥发送给攻击者。挑战者输出随机比特 $b \\in \\{ 0 , 1 \\}$ 并停止攻击。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "情况2如果 $A _ { a } \\cap A _ { b } \\neq \\emptyset$ 且 $A _ { a } \\subset A _ { b }$ ，挑战者选取随机数$\\omega , \\varepsilon \\in Z _ { q }$ （204号 ， 计算密钥 SK=ga(β+) 和$S K ^ { \\prime } = \\left\\{ g ^ { \\omega } h ^ { \\varepsilon } , g ^ { \\varepsilon } , C _ { 0 } = P K ^ { \\omega } , C _ { j } = D _ { j } ^ { \\omega } \\right\\} _ { j \\in A _ { a } }$ ，将密钥发送给攻击者。挑战者输出随机比特 $b \\in \\{ 0 , 1 \\}$ 并停止攻击。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "情况3如果 $A _ { a } \\subset A _ { b }$ ，挑战者选取随机数 $\\omega , \\varepsilon \\in Z _ { q }$ ，计算密钥 $S K = g ^ { a ( b + \\omega ) }$ ， $C _ { 0 } = g ^ { a \\omega }$ 和 $\\left\\{ C _ { j } = { B _ { j } } ^ { \\omega } \\right\\} _ { j \\in A _ { a } }$ ，外包密钥为$S K ^ { \\prime } { = } \\left\\{ g ^ { \\omega } h ^ { \\varepsilon } , g ^ { \\varepsilon } , C _ { 0 } , \\left\\{ C _ { j } \\right\\} _ { j \\in A _ { a } } \\right\\}$ 将密钥发送给攻击者，同时将 $\\mathit { S K }$ ，$S K ^ { \\prime }$ 和 $T _ { a }$ 记入表中。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "假设该阶段进行了 $q _ { E 1 }$ 次询问。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "挑战阶段：攻击者生成两个等长明文 $m _ { 0 }$ 和 $m _ { 1 }$ 以及想挑战的属性结构 $T _ { _ A }$ 给挑战者。挑战者计算$D _ { 1 } = \\lambda _ { 1 } ^ { ~ a }$ ， $D _ { 2 } = { \\lambda _ { 2 } } ^ { a } \\quad , . . . , D _ { N } = { \\lambda _ { N } } ^ { a }$ 同时为 $T _ { _ A }$ 选取随机数 $\\omega , \\varepsilon \\in Z _ { q }$ ，生成密钥 $S K = g ^ { a ( b + \\omega ) }$ 和 $S K ^ { \\prime } = \\left\\{ g ^ { \\omega } h ^ { \\varepsilon } , g ^ { \\varepsilon } , C _ { 0 } = P K ^ { \\omega } , C _ { j } = { D _ { j } } ^ { \\omega } \\right\\} _ { j \\in A _ { a } }$ 。挑战者选取随机比特 $\\nu \\in \\{ 0 , 1 \\}$ ，用该密钥加密明文 $m _ { \\nu }$ 。将常数 $b$ 作为秘密分割数得到 $\\{ y _ { 1 } ( 0 ) , y _ { 2 } ( 0 ) , . . . , y _ { m } ( 0 ) \\}$ ，计算 $T _ { 0 } = g ^ { a ( m + c ) }$ 和$T _ { 1 } = h ^ { a ( m + c ) }$ ，部分密文为密文 $C T ^ { \\prime } = \\left\\{ g ^ { y _ { 1 } ( 0 ) } D _ { 1 } , g ^ { y _ { 2 } ( 0 ) } D _ { 2 } , . . . , g ^ { y _ { n } ( 0 ) } D _ { n } \\right\\}$ 。设置 $t = c$ 完全密文为 $C T = \\left\\{ T _ { 0 } , T _ { 1 } , g ^ { t } , D K \\cdot e \\left( g , g \\right) ^ { \\alpha \\beta t } , C T ^ { \\prime } , S E _ { D K } \\left( M \\right) \\right\\}$ 因为：",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { r l } & { \\quad \\frac { e } { e } \\Big ( \\underbrace { g ^ { x } } _ { \\kappa ^ { \\mathrm { o u r d } } r e ^ { m } } , g ^ { x } \\Big ) = e \\Big ( g ^ { x _ { \\mathrm { i } } ( 0 ) } , g ^ { \\omega \\prime } \\Big ) } \\\\ & { \\quad \\quad \\quad \\quad \\quad \\quad e \\Big ( g ^ { \\alpha } , \\lambda _ { i } ^ { \\omega \\prime } \\Big ) } \\\\ & { \\quad \\quad \\quad \\quad F _ { R o n t } = \\displaystyle \\prod _ { x \\in R \\mathbb { I } \\mathbb { I } \\neq r e ^ { m } } \\kappa _ { x } ^ { \\Delta _ { \\mathrm { m a x } ( x ) , \\bar { x } _ { \\mathrm { i } } } ( 0 ) } } \\\\ & { \\quad \\quad \\quad = \\displaystyle \\prod _ { x \\in R \\mathbb { I } \\mathbb { I } \\neq r e ^ { m } } \\Big ( g , g \\Big ) ^ { \\alpha \\omega \\eta _ { \\mathrm { m e r e } ( x ) } ( m d e x ( x ) ) \\Delta _ { \\mathrm { i n d e t } ( 1 ) , \\bar { x } _ { \\mathrm { i } } } ( 0 ) } } \\\\ & { \\quad \\quad \\quad = e \\Big ( g , g \\Big ) ^ { \\alpha \\omega } \\sum _ { x \\in R \\mathbb { I } \\neq r e ^ { m } ( x ) } ( i n d e x ( x ) ) \\Delta _ { \\mathrm { i n d e t } ( 1 ) , \\bar { x } _ { \\mathrm { i } } } ( 0 ) } \\\\ & { \\quad \\quad \\quad = e \\Big ( g , g \\Big ) ^ { \\alpha \\omega \\eta _ { \\mathrm { l o s s } } ( 0 ) } } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "且 ${ e } \\left( g , g \\right) ^ { \\alpha \\beta t } = { e } \\left( g , g \\right) ^ { a b c }$ ，所以 $D K \\cdot e \\left( g , g \\right) ^ { \\alpha \\beta t }$ 是有效密文。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "询问阶段2：攻击者继续选取询问结构向挑战者进行询问，挑战者查表，询问的结构不能是表中任一结构的子树，假设该阶段询问了 $q _ { E 2 }$ 次。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "猜测阶段：攻击者根据查询的结果猜测密文对应于哪一个明文，输出比特 $b ^ { \\prime } \\in \\{ 0 , 1 \\}$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "证明：要使攻击者能够顺利进行攻击就需要攻击者能够正确地进行询问，询问阶段1的属性必须包含于属性集 $A _ { b }$ 0系统共有 $N$ 个属性，而挑战者掌握的已Corrupted 的属性有 $M$ 个，挑战者可以利用这些属性将DBDH问题嵌入到这些属性中，前提是攻击者提出的属性不能超出 $A _ { b }$ 。从 $N$ 个属性中任意选取属性共有 $2 ^ { \\scriptscriptstyle N }$ 种选择，正确的情况有 $2 ^ { M }$ 种。所有询问都正确的概率是 $2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } ) }$ ，因为 $\\left| \\operatorname* { P r } \\left[ b = b ^ { \\prime } \\right] - 1 / 2 \\right| = \\varepsilon$ ，所以：",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { r l } & { \\operatorname* { P r } \\Big [ f \\left( g ^ { a } , g ^ { b } , g ^ { c } , e \\left( g , g \\right) ^ { a b c } \\right) - f \\left( g ^ { a } , g ^ { b } , g ^ { c } , K \\right) \\neq 0 \\Big ] } \\\\ & { \\geq \\operatorname* { P r } \\big [ \\exists A _ { a } : A _ { a } - A _ { b } \\neq \\emptyset \\big ] \\times 1 / 2 + \\operatorname* { P r } \\big [ \\forall A _ { a } : A _ { a } \\subset A _ { b } \\big ] \\times \\left( 1 / 2 - \\varepsilon \\right) } \\\\ & { = \\left( 1 - 2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } ) } \\right) \\times 1 / 2 + 2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } ) } \\times \\left( 1 / 2 - \\varepsilon \\right) } \\\\ & { = 1 / 2 - 2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } ) } / 2 + 2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } ) } / 2 - 2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } ) } \\times \\varepsilon } \\\\ & { = 1 / 2 - 2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } ) } \\times \\varepsilon } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "其中 $\\boldsymbol { \\varepsilon }$ 不大于 $1 / 2$ ，所以 $\\boldsymbol { B }$ 的优势不大于 $2 ^ { ( M - N ) ( q _ { E 1 } + q _ { E 2 } + 1 ) }$ 。证毕。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "5 性能比较 ",
        "text_level": 1,
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "将本文的方案与文献[11，12]的方案进行比较，比较的标准分为时间和空间两个指标。首先对所有方案进行时间指标的分析，为隐藏用户的属性信息需要对每个属性进行隐藏，相应地需要对每个属性进行双线性变换，本文的方案与文献[12]在解密时计算量相近。由于运用了外包加密算法，大部分的加解密计算不需要用户来完成。",
        "page_idx": 3
    },
    {
        "type": "table",
        "img_path": "images/700f6db1f3b5eaf03d376d096a97a83c9596b64a668d0b6c4f3c39eca2ea8510.jpg",
        "table_caption": [
            "Table 1Comparison of cost of encrytion "
        ],
        "table_footnote": [
            "表2解密计算量比较"
        ],
        "table_body": "<html><body><table><tr><td>scheme</td><td>outsourcing encrypt</td><td>encrypt of user</td></tr><tr><td>Scheme in [11]</td><td>(|S|+2)C</td><td>5C+2CT</td></tr><tr><td>Scheme in [12]</td><td>(2|S|+2)C</td><td>2C+2Cr</td></tr><tr><td>本文方案</td><td>(|S|+2)C</td><td>3C+2CT</td></tr></table></body></html>",
        "page_idx": 3
    },
    {
        "type": "table",
        "img_path": "images/02978c3bfb447eac4ab0170681bb77ddbb81eacc4a8e1880e4e67d45aa250473.jpg",
        "table_caption": [
            "表1加密计算量比较"
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td>scheme</td><td>outsourcing decrypt</td><td>decrypt of user</td></tr><tr><td>Scheme in [11]</td><td>(2|S|+2)E+(Ta+2)CT</td><td>(2|S|+1)E+2|S|Cr</td></tr><tr><td>Scheme in [12]</td><td>(2|S|+2)E+(Ta+1)Cr</td><td>E+2CT</td></tr><tr><td>本文方案</td><td>(2|S|+2)E+(Ta+2)Cr</td><td>E+2CT</td></tr></table></body></html>",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "文献[12]的方案中的密钥长度为属性数的两倍，因为该算法中需要为每个属性计算单独的双线性变换，变换中的两个因子都不一样，所以该方案中的密钥和密文长度都随着属性的增加而呈现两倍的增长。本文方案的双线性变换会共享一个因子，所以可以节省一半的存储孔家。表中的S为用户的属性集，IS|表示 S 内元素个数。lg是集合Go中的生成元g的长度，lgr是集合 $\\mathbf { G } _ { \\mathrm { T } }$ 的生成元的长度。C 和 $\\mathbf { C } _ { \\mathrm { { T } } }$ 分别表示群${ \\bf G } _ { 0 }$ 和 $\\mathbf { G } _ { 1 }$ 上的计算，E表示双线性变换计算。可以看出在保持计算量和安全性不变的基础上大大缩短了密文和密钥的长度，使密文和密钥缩短到原来的一半。",
        "page_idx": 3
    },
    {
        "type": "table",
        "img_path": "images/cdd8dc74a67e0863ba94134472a71332c9fe34d8c2b65176e3f2649de38219b3.jpg",
        "table_caption": [
            "Table 2Comparison of cost of decrytion ",
            "表3存储开销比较",
            "Table 3Comparison of storage "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td>scheme</td><td>length of plaintext</td><td>length of key</td></tr><tr><td>Scheme in [11]</td><td>(3|S|+1)lg|+lgr|</td><td>(|S|+2)|gl</td></tr><tr><td>Scheme in [12]</td><td>(2|S|+3)|g|+lgr|</td><td>(2|S|+3)|gl</td></tr><tr><td>本文方案</td><td>(|S|+3)|g|+lgr|</td><td>(|S|+3)|gl</td></tr></table></body></html>",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "6 结束语",
        "text_level": 1,
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "本文通过对现有的密文策略属性加密方案进行改进，简化了数据拥有者外包私钥的生成过程，减少了属性中心生成的属性分量的个数，从而缩短了密文和密钥长度，节省了加解密的存储和计算开销，在此基础上保证了系统的安全性不变。本文基于DBDH问题在标准模型下证明了该方案的安全性，通过性能分析和安全性证明表明了本文所提方案不但具有较高的效率还有较好的安全性。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "参考文献：",
        "text_level": 1,
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "[1]崔勇，宋健，缪葱葱，等．移动云计算研究进展与趋势[J].计算机 学报,2017,40(2): 273-295.(Cui Yong,Song Jian,Miao Congcong,et al.Research progress and trend of mobile cloud computing [J].Journal of Computer Science,2017,40(2):273-295.)   \n[2]方巍．从云计算到雾计算的范式转变[J]．南京信息工程大学学报, 2016,8(5): 404-414.(Fang Wei.Paradigm shift from cloud computing to fog computing [J].Journal of Nanjing University of Information Science and Technology,2016,8(5): 404-414.)   \n[3]Barrett D,Kipper G.Cloud Computing and the Forensic Challenges [J]. Virtualization and Forensics,2010(1):197-209.   \n[4]Pirretti M,Traynor P,McDaniel P,et al. Secure attribute-based systems [J]//Journal of Computer Security,2010,18 (5):799-837.   \n[5]Bethencourt J,Sahai A,Waters Brent.Ciphertext-Policy attribute-based encryption [C]//Proc of the 29th IEEE Symposium on Security and Privacy.Washington DC:IEEE Computer Society,2007:321-334.   \n[6]Maji HK,Prabhakaran M,Rosulek M.Attribute-based signatures [C]// Proc of the 1lth International Conference on Topics in Cryptology. Berlin: Springer-Verlag,2011:376-392.   \n[7]Alex Escala,Javier Herranz,Paz Morillo.Revocable attribute-based signatures with adaptive security in the standard model [C]//Proc of the 4th International Conference on Progress in Cryptology in Africa. Berlin: Springer-Verlag,2011:224-241.   \n[8]Li Jin，Chen Xiaofen，Li Jingwei，et al.Secure outsourced attribute-based signatures [J].IEEE Trans on Parallel & Distributed Systems,2014,25 (12):3285-3294.   \n[9]Lewko A,Waters B.Unbounded HIBE and attribute-based encryption [C]//Proc of the 3Oth International Conference on Theory and Applications of Cryptographic Techniques.Berlin: Springer-Verlag, 2011: 547-567.   \n[10] Jin Xin,KrishnanR,SandhuR.Aunified attribute-based access control model covering DAC,MAC and RBAC[C]//Proc of the 26th of Data and Applications Security and Privacy.Berlin: Springer, 2O12:41-55.   \n[11] Zhang Peng,Chen Zehong,Joseph K.Liu,et al.An efficient access control scheme with outsourcing capability and attribute update for fog computing [J]. Future Generation Computer Systems,2018(78): 753-762.   \n[12] Huang Qinlong,Yang Yixian,Wang Licheng.Secure data access control with ciphertext update and computation outsourcing in fog computing for Internet of things [J].IEEE Access,2017,5 (99):12941-12950.   \n[13] Chase M,Chow S S M.Improving privacy and securityin multi-authority attribute-based encryption [C]// Proc of the 16th ACM Conference on Computer and Communications Security. New York: ACMPress,2009:121-130.   \n[14]Li Fei,Yogachandran Rahulamathavan,Muttukrishnan Rajarajan,et al. Low complexity multi-authority attribute based encryption scheme for mobile cloud computing [C]// Proc of the 7th IEEE International Symposium on Service-Oriented System Engineering.Piscataway: IEEE Press,2013:573-577.   \n[15]Dan B,Franklin M.Identity-based encryption from the weil pairing [J]. Grypto,2003,32(3):213-229. ",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 4
    }
]