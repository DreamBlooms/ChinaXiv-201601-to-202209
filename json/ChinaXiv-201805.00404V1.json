[
    {
        "type": "text",
        "text": "稀疏条件下的重叠子空间聚类算法",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "邱云飞ä，费博雯ʰ，刘大千‘，刘兴ä(辽宁工程技术大学 a.软件学院;b.工商管理学院;c.电子与信息工程学院，辽宁 葫芦岛 125105)",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "摘要：现有子空间聚类算法不能很好地平衡子空间数据的稠密性和不同子空间数据稀疏性的关系，且无法处理数据的重叠问题。针对上述问题，提出一种稀疏条件下的重叠子空间聚类(OSCSC)算法。算法利用 $l _ { \\mathrm { { l } } }$ 范数和Frobenius范数的混合范数表示方法建立子空间表示模型，并对 $l _ { 1 }$ 范数正则项进行加权处理，提高不同子空间的稀疏性和同一子空间的稠密性；然后对划分好的子空间使用一种服从指数族分布的重叠概率模型进行二次校验，判断不同子空间数据的重叠情况，进一步提高聚类的准确率。在人造数据集和真实数据集上分别进行测试，实验结果表明，OSCSC算法能够获得良好的聚类结果。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "关键词：重叠子空间聚类；混合范数；重叠概率模型；指数族分布 中图分类号：TP301.6 doi:10.3969/j.issn.1001-3695.2017.08.0904 ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Novel algorithm of overlapping subspace clustering under sparse condition ",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Qiu Yunfeia, Fei Bowenbt, Liu Daqianc, Liu Xinga (a.School of Software，b.Schoolof Business& Management,c.School of Electronics Information Engineering Liaoning Technical University,Huludao Liaoningl25105,China) ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Abstract: Theexisting subspace clustering algorithms cannot balance the densityof thedata in the same subspace and the sparsity ofthedata between diferent subspaces and most algorithms cannot solvethe overlapof data.To solve the above problems,this paper proposed anovel algorithmofoverlapping subspace clustering algorithmunder sparsecondition (OSCSC). The algorithmused the mixed norm representation methodofLl normandFrobenius norm to establish the subspace representation model,andthe weightedLlnormregulartrcould improve thesparsityofdiferentsubspacesandthedensity ofthe same subspace.Then,thealgorithmperformedrechecks onthe partitioned subspaces byusing anoverlapping probability model subject to exponential familydistributiontodetermine whether exist overlapping in different subspaces，which could furtherimprove theaccuracyofclustering.Theresultsoftheexperimentonbothartificialdatasetsandreal-worlddatasetsshow that the algorithm has better clustering performance by being compared to other contrast algorithms. ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "Key Words: overlapping subspace clustering; mixed norm; overlapping probabilitymodel; exponentialfamilydistribution ",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "0 引言",
        "text_level": 1,
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "聚类分析是数据挖掘领域的重要研究内容之一，在机器学习、医学生物分析和计算机视觉等方面具有广泛应用[I\\~3]。近些年来数据规模迅速增长，数据规模和维度也越来越大，在处理和分析这样的数据集时，由于样本分布稀疏，数据间距离几乎相同，传统的聚类方法往往无法获得准确的聚类结果[4]。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "为了解决数据规模较大和数据维度较高等问题，Agrawal等人[5首次将子空间聚类的概念应用于聚类问题的分析中。此后，根据这一思想，国内外学者和研究人员相继提出了许多子空间聚类方法。现有子空间聚类方法可大致被分为5类：迭代方法、代数方法、统计方法、基于矩阵分解的方法和基于谱聚类的方法[。其中较为流行的子空间聚类算法是基于谱聚类框架的方法，例如稀疏子空间聚类(sparse subspace clusteringSSC)[7]方法、最小二乘回归子空间聚类算法(least squaresregression，LSR)[8]和低秩表示子空间聚类算法(low-rankrepresentation,LRR)[9]。以上三种方法通过将某个数据样本由其他样本线性表示构建相似度矩阵并将其转换为Laplacian矩阵，然后对该矩阵特征分解，根据谱聚类的思想对得到的特征值和特征向量进行聚类。在此基础上，Xu等人[10]提出重加权稀疏子空间聚类(reweighted sparse subspace clustering,RSSC)方法，利用log-sum 启发方法对 $l _ { 1 }$ 范数进行迭代加权，提高子空间稀疏性。Zhang等人[1]提出一种基于低秩表示的子空间聚类改进算法，在构建子空间聚类模型时，采用核范数和Frobenius 范数代替秩函数，并利用非精确的增广拉格朗日乘子方法进行优化得到最优系数矩阵。",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 0
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "上述子空间聚类算法虽然从一定程度上提高了聚类性能，但由于其均属于硬划分聚类方法，忽略了数据簇间存在重叠的问题。在实际处理子空间聚类问题时，不同子空间的数据会存在重叠部分，不完全独立，在进行聚类时会导致一些数据不能归到正确的子空间内，影响聚类精度[12]。根据数据划分不确定性，Banerjee 等人[13]提出一种基于模型的重叠聚类算法(model-basedoverlappingclustering,MOC)，该算法利用概率模型的方法处理数据间的重叠问题，判断某一数据样本是否属于多个类簇。 $\\mathrm { F u } ^ { [ 1 4 ] }$ 等人提出了一种贝叶斯重叠子空间聚类算法(Bayesianoverlapping subspace clustering,BOSC)，通过构建数据矩阵的层次生成模型来发现数据间的重叠结构，该算法没有充分考虑数据间的结构关系，在处理维数较高的数据集时效率较低。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "针对上述聚类算法存在的问题，本文提出一种稀疏条件下的重叠子空间聚类算法(overlapping subspace clustering undersparse condition,OSCSC)，算法利用加权l范数和 Frobenius 范数的混合范数子空间表示方法对数据空间进行划分，能够更好地保证同一子空间数据的稠密性和不同子空间数据的稀疏性。然后使用一种重叠概率模型对子空间内的数据进行重叠校验，判断其是否属于多个子空间。本文算法主要基于稀疏子空间聚类方法的基础上对数据样本进行重叠判断，允许一个数据对象属于多个子空间，当子空间划分过程发生错误时有利于将数据归于到正确的子空间内，能够有效提高聚类的准确率。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "1 子空间聚类 ",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "近年来，子空间聚类成为处理高维数据的主要研究方法。其中以谱聚类为基础的子空间聚类方法得到了广泛关注。该类方法通过寻找低维空间的表示系数构造基于自表达模型的相似矩阵，然后利用谱聚类算法得到最终的聚类结果。SSC和LSR算法均具有这样的性质，认为在整个数据空间内的每个数据点$\\boldsymbol { x } _ { j }$ 可用其他数据点线性表示",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nx _ { j } = \\sum _ { i \\ne j } ^ { n } z _ { i j } x _ { i } + \\eta _ { j }\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "其中： $n$ 为数据点个数； $z _ { i j }$ 为数据点 $x _ { i }$ 和 $\\boldsymbol { x } _ { j }$ 之间的相似系数，用于构建相似矩阵； $\\eta _ { j }$ 用于描述自表示模型中的偏差或噪声数据。当 $x _ { i }$ 和 $\\boldsymbol { x } _ { j }$ 不属于同一子空间时 $z _ { i j } = 0$ 。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "SSC算法求解子空间聚类模型可表示为",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { \\boldsymbol { z } } \\left\\| \\boldsymbol { Z } \\right\\| _ { 1 } \\qquad \\mathrm { s . t . } \\ X = X \\boldsymbol { Z } \\ , \\ z _ { j j } = 0\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "其中： $\\left\\| \\cdot \\right\\| _ { 1 }$ 为 $l _ { 1 }$ 范数， $X = [ x _ { 1 } , \\cdots , x _ { N } ]$ 为数据矩阵。 $Z$ 是由 $z _ { j }$ 组成的系数矩阵。对于有噪声数据，SSC可以扩展为",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { \\boldsymbol { z } } \\left\\| \\boldsymbol { X } - \\boldsymbol { X } \\boldsymbol { Z } \\right\\| _ { F } ^ { 2 } + \\left\\| \\boldsymbol { Z } \\right\\| _ { 1 } \\quad \\mathrm { s . } t . \\boldsymbol { z } _ { j j } = 0\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "LSR通过最小化系数矩阵 $Z$ 的Frobenius范数建立如下目标函数：",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nm i n \\left\\| Z \\right\\| _ { F } ^ { 2 } \\qquad { \\mathrm { s . t . } } \\ X = X Z \\ , \\ z _ { j j } = 0\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "对于有噪声数据，LSR可扩展为",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { \\ b { z } } \\left\\| \\ b { X } - \\ b { X Z } \\right\\| _ { \\ b { F } } ^ { 2 } + \\lambda \\left\\| \\ b { Z } \\right\\| _ { \\ b { F } } ^ { 2 } \\quad \\mathrm { s . t . } \\ : z _ { j j } = 0\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "根据相似矩阵的对称性和非负性，相似矩阵W可被定义为",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\nU = \\frac { 1 } { 2 } ( \\left| Z \\right| { + } \\left| Z ^ { \\mathrm { T } } \\right| )\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "然后将谱聚类应用于相似矩阵中获得聚类结果。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2 稀疏条件下的重叠子空间聚类",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "本文提出的OSCSC算法融合子空间聚类以及重叠聚类的思想，旨在不同子空间的重叠聚类问题。本文算法利用迭代加权的 $l _ { 1 }$ 范数和Frobenius 范数的混合范数表示方法建立子空间聚类模型，将高维数据通过低维子空间线性表示，使用线性交替方向法对模型进行优化。然后对得到了子空间结果采用重叠概率模型估计数据的重叠情况。本文算法与以往基于硬划分的子空间聚类技术的不同之处在于允许某一数据属于一个或多个子空间，可进一步提高聚类精度，减少聚类错误。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2.1加权混合范数的子空间表示",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2.1.1子空间表示模型",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "子空间聚类方法核心在于子空间模型的建立。本文结合SSC 和LSR算法思想，提出一种混合范数的子空间表示方法，在保证类间数据稀疏的同时，增加类内数据的稠密性。定义 $X$ 为 $M \\times N$ 的数据矩阵，包含 $N$ 个列向量 $\\left\\{ x _ { j } \\in \\mathbf { R } ^ { M } \\right\\} _ { j = 1 } ^ { N }$ 可由 $J$ 个子空间线性表示，子空间聚类的目的是将数据矩阵 $\\mathrm { \\Delta } X$ 中的列向量 $\\boldsymbol { x } _ { j }$ 划分到正确的子空间中。子空间聚类模型可表示为",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { z } \\left. \\lambda \\bigl \\| Z \\bigr \\| _ { 1 } + \\frac { 1 - \\lambda } { 2 } \\bigl \\| Z \\bigr \\| _ { F } ^ { 2 } \\right.\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "对于有噪声的数据集，模型可以表示为",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { \\boldsymbol { z } } \\ \\lambda \\big \\| \\boldsymbol { Z } \\big \\| _ { 1 } + \\frac { 1 - \\lambda } { 2 } \\big \\| \\boldsymbol { Z } \\big \\| _ { F } ^ { 2 } + \\big \\| \\boldsymbol { X } - \\boldsymbol { X } \\boldsymbol { Z } \\big \\| _ { F } ^ { 2 }\n$$",
        "text_format": "latex",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "其中： $\\left\\| \\cdot \\right\\| _ { F }$ 为 Frobenius 范数； $\\lambda \\in \\left[ 0 , 1 \\right]$ 为权衡系数，用于权衡两个正则化项间的关系； $Z$ 为系数矩阵，提供了关于子空间的向量分割问题的条件。",
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "2.1.2加权方式",
        "text_level": 1,
        "page_idx": 1
    },
    {
        "type": "text",
        "text": "在处理实际的问题时，真实数据集内的数据间情况复杂，只通过 $l _ { 1 }$ 正则化项保证子空间稀疏性的效果并不理想。文献[1015]均提出针对 $l _ { 1 }$ 正则化项的加权方法，并经过大量实验证明迭代更新权值的 $l _ { \\mathrm { { 1 } } }$ 范数( $\\operatorname* { m i n } _ { { \\boldsymbol { x } } \\in R ^ { n } } \\left\\| { \\boldsymbol { w } } { \\boldsymbol { x } } \\right\\| _ { 1 }$ )与单独运用 $l _ { \\mathrm { 1 } }$ 范数 $\\operatorname* { m i n } _ { { \\boldsymbol { x } } \\in R ^ { n } } \\left\\| { \\boldsymbol { x } } \\right\\| _ { 1 }$ ）相比能够获得更为稀疏的系数结构，平衡了 $l _ { 1 }$ 范数和 $l _ { 0 }$ 范数间的差异，使 $l _ { 1 }$ 更能逼近 $l _ { 0 }$ 。文献[14]通过求解",
        "page_idx": 1
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { x \\in R ^ { n } } \\sum _ { i = 1 } ^ { n } \\ln \\left( \\left| x _ { i } \\right| + \\varepsilon \\right) , \\qquad \\mathrm { s . t . } \\quad A x = b\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "迭代更新得到加权方式",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nw _ { i } ^ { ( t ) } = \\left( \\left| x _ { i } ^ { ( t - 1 ) } \\right| + \\varepsilon \\right) ^ { - 1 }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中： $\\boldsymbol { w } _ { i } ^ { t }$ 为数据点 $x _ { i }$ 在第 $\\mathbf { \\Psi } _ { t }$ 次迭代中对应的权值， $\\boldsymbol { \\varepsilon }$ 为控制参数。本文将迭代加权 $l _ { 1 }$ 范数的思想应用于混合范数子空间表示模型中，则式(10)可以表示为",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { \\boldsymbol { z } } \\ \\lambda \\big \\| \\boldsymbol { W } \\odot \\boldsymbol { Z } \\big \\| _ { 1 } + \\frac { 1 - \\lambda } { 2 } \\big \\| \\boldsymbol { Z } \\big \\| _ { F } ^ { 2 } + \\big \\| \\boldsymbol { X } - \\boldsymbol { X } \\boldsymbol { Z } \\big \\| _ { F } ^ { 2 }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "2.1.3模型优化求解",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "针对优化问题式(13)可将其转换为",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m i n } _ { \\boldsymbol { z } } \\ \\lambda \\big \\| \\boldsymbol { W } \\odot \\boldsymbol { Z } \\big \\| _ { 1 } + \\frac { 1 - \\lambda } { 2 } \\big \\| \\boldsymbol { Z } \\big \\| _ { F } ^ { 2 } + \\big \\| \\boldsymbol { E } \\big \\| _ { F } ^ { 2 }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nX - X Z = E \\ , \\ z _ { j j } = 0\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "对上述问题利用线性交替方向法(linearizedalternatingdirectionsmethod,LADM)[6优化。通过引入拉格朗日乘子 $\\mu$ ，得到增广拉格朗日函数",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nL ( Z , E , \\mu ) = \\lambda { \\big \\| } W \\odot Z { \\big \\| } _ { 1 } + { \\frac { 1 - \\lambda } { 2 } } { \\big \\| } Z { \\big \\| } _ { F } ^ { 2 } + { \\big \\| } E { \\big \\| } _ { F } ^ { 2 }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n+ \\frac { \\rho } { 2 } \\big \\| X - X Z - E \\big \\| _ { F } ^ { 2 } + \\mathrm { t r } ( \\mu ^ { \\mathrm { { T } } } ( X - X Z - E ) ) \\quad \\mathrm { s . t . ~ } z _ { { \\scriptscriptstyle j } { \\scriptscriptstyle j } } = 0\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中： $\\rho > 0$ 为惩罚参数。利用LADM优化问题式(15)，首先定义 $k$ 为迭代次数，固定 $E ^ { ( k ) }$ ，更新 $Z ^ { ( k + 1 ) }$ ，即",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { c } { { \\displaystyle { \\cal Z } ^ { ( k + 1 ) } = \\displaystyle { \\operatorname* { m i n } _ { Z ^ { ( k ) } } { \\cal L } ( Z ^ { ( k ) } , E ^ { ( k ) } , \\mu ^ { ( k ) } ) \\approx } } } \\\\ { { { \\cal S } _ { \\displaystyle { \\frac { \\lambda } { \\theta \\mu ^ { ( k ) } } } } \\left\\{ { \\cal Z } ^ { ( k ) } + \\displaystyle { \\frac { 1 } { \\theta } [ X ^ { \\top } ( X - X Z ^ { ( k ) } - E ^ { ( k ) } + \\displaystyle { \\frac { \\mu ^ { ( k ) } } { \\rho ^ { ( k ) } } } ) - \\displaystyle { \\frac { 1 - \\lambda } { 2 \\rho ^ { ( k ) } } } Z ^ { ( k ) } ] } \\right\\} } } \\\\ { { { \\mathrm { s . t . } \\mathrm { z } _ { \\displaystyle { j } } ^ { ( k + 1 ) } = 0 } } } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中： $S _ { \\tau } ( q )$ 为收缩阈值算子，具体定义为$S _ { \\tau } ( q ) = \\mathrm { s g n } ( q ) \\mathrm { m a x } ( \\left| q \\right| - \\tau , 0 )$ ， $\\theta = 1 . 1 \\sigma ^ { 2 } \\left( \\sigma \\right.$ 为数据矩阵 $X$ 的最大奇异值)。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "然后固定 $Z ^ { ( k + 1 ) }$ ，更新 $E ^ { ( k + 1 ) }$ ，即",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nE ^ { ( k + 1 ) } = \\operatorname* { m i n } _ { Z ^ { ( k ) } } L ( Z ^ { ( k + 1 ) } , E ^ { ( k ) } , \\mu ^ { ( k ) } ) = \\frac { \\mu ^ { ( k ) } + \\rho ^ { ( k ) } ( X - X Z ^ { ( k + 1 ) } ) } { 2 + \\rho ^ { ( k ) } }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\mathbf { s . t . } \\mathbf { Z } _ { j j } ^ { ( k + 1 ) } = 0\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "最后，分别更新拉格朗日乘子 $\\mu$ 和惩罚参数 $\\rho$ ，LADM具体优化过程如下。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "算法1利用LADM优化问题式(15)",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "输入：数据矩阵 $X$ ，权衡系数 $\\lambda$ ",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "输出：系数矩阵 $Z$ ，噪声矩阵 $E$ ",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "初始化： $Z ^ { ( 0 ) } = 0$ ， $E ^ { ( 0 ) } = 0$ ， $\\boldsymbol { \\mu } ^ { ( 0 ) } = 0$ ， $\\rho ^ { ( 0 ) } = 1 0 ^ { - 6 }$ ， $\\gamma = 1 . 6$ ，$\\theta = 1 . 1 \\sigma ^ { 2 } , \\varepsilon _ { 1 } = 1 0 ^ { - 4 } , \\varepsilon _ { 2 } = 1 0 ^ { - 5 }$ ",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "固定 $E ^ { ( k ) }$ ，更新 $Z ^ { ( k + 1 ) }$ （204号",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { c } { { \\displaystyle Z ^ { ( k + 1 ) } = \\underset { Z ^ { ( k ) } } { \\mathrm { m i n } } L ( Z ^ { ( k ) } , E ^ { ( k ) } , { \\boldsymbol { \\mu } } ^ { ( k ) } ) \\approx } } \\\\ { { \\displaystyle S _ { \\frac { \\lambda } { \\theta \\mu ^ { ( k ) } } } \\left\\{ Z ^ { ( k ) } + \\frac { 1 } { \\theta } [ X ^ { \\top } ( X - X Z ^ { ( k ) } - E ^ { ( k ) } + \\frac { { \\boldsymbol { \\mu } } ^ { ( k ) } } { \\rho ^ { ( k ) } } ) - \\frac { 1 - \\lambda } { 2 \\rho ^ { ( k ) } } Z ^ { ( k ) } ] \\right\\} } } \\\\ { { \\mathrm { s . t . } { \\mathrm { Z } } _ { j j } ^ { ( k + 1 ) } = 0 } } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "固定 $Z ^ { ( k + 1 ) }$ ，更新 $E ^ { ( k + 1 ) }$ ",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { l } { { { \\cal { E } } ^ { { ( k + 1 ) } } = \\displaystyle \\operatorname* { m i n } _ { Z ^ { ( k ) } } { \\cal { L } } ( Z ^ { ( k + 1 ) } , E ^ { ( k ) } , { \\mu } ^ { ( k ) } ) = \\displaystyle \\frac { { \\mu } ^ { { ( k ) } } + { \\rho } ^ { { ( k ) } } ( X - X Z ^ { ( k + 1 ) } ) } { 2 + { \\rho } ^ { { ( k ) } } } \\nonumber } } \\\\ { { \\mathrm { s . t . } { z } _ { j j } ^ { { ( k + 1 ) } } = 0 ~ } } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "更新权值 ",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nw _ { i } ^ { ( k + 1 ) } = \\frac { 1 } { \\left( \\left| z _ { i } ^ { ( k ) } \\right| + \\varepsilon \\right) }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "更新拉格朗日乘子",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\mu ^ { ( k + 1 ) } = \\mu ^ { ( k ) } + \\rho ^ { ( k ) } ( X - X Z ^ { ( k + 1 ) } - E ^ { ( k + 1 ) } )\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "更新惩罚参数 $\\rho ^ { ( k + 1 ) } = \\operatorname* { m i n } ( \\gamma \\cdot \\rho ^ { ( k ) } , 1 0 ^ { 1 0 } )$ ",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "收敛条件： $\\left\\| X - X Z ^ { ( k ) } - E ^ { ( k ) } \\right\\| _ { F } / \\left\\| X \\right\\| _ { F } < \\varepsilon _ { 1 }$ ，",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\n\\operatorname* { m a x } ( \\left\\| E ^ { ( k ) } - E ^ { ( k - 1 ) } \\right\\| _ { F } / \\left\\| X \\right\\| _ { F } , \\left\\| Z ^ { ( k ) } - Z ^ { ( k - 1 ) } \\right\\| _ { F } / \\left\\| X \\right\\| _ { F } ) < \\varepsilon _ { 2 } ,\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "由上式可得出优化后的系数矩阵 $z ^ { * }$ ，进而得到相似矩阵$U = \\frac { 1 } { 2 } ( \\big | Z ^ { * } \\big | { + } \\big | ( Z ^ { * } ) ^ { \\mathrm { T } } \\big | )$ ，然后利用一种标准分割法 Ncut[17]对子空间进行分割并得到子空间集合。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "2.2重叠概率模型",
        "text_level": 1,
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "尽管使用加权的混合范数子空间表示方法能够提高同一子空间数据的稠密性和不同子空间数据的稀疏性，但子空间聚类过程中依然存在错误，且该方法属于硬划分聚类方法，一般只允许一个数据样本仅属于一类，当聚类发生错误时无法校验。针对此问题，本文使用一种重叠概率模型用于判断已划分的子空间内数据是否可以属于多个子空间，给定高维数据集 $X$ ，将已得到 $L$ 个子空间集合表示为 $\\cup _ { l = 1 } ^ { L } S _ { l }$ ，其中每个子空间都代表一类数据。设 $Y = Y _ { 1 } \\cup Y _ { 2 } \\cup \\cdots \\cup Y _ { L }$ 为来自子空间 $\\textstyle \\bigcup _ { l = 1 } ^ { L } S _ { l }$ 的数据针对 $( S , Y )$ 进行二次校验，判断子空间是否存在重叠部分。这样当数据被误分时可以及时校验其是否属于其他子空间，能够进一步提高聚类的准确率。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "重叠概率模型是一种服从指数分布族[18的概率模型，指数分布族的定义是指概率分布满足以下形式",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\nf _ { Y } \\left( y \\vert \\theta \\right) = e x p \\left\\{ \\theta T \\left( y \\right) - \\varphi \\left( \\theta \\right) \\right\\}\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中: $T ( y )$ 是分布的充分统计量， $\\theta$ 为自然参数， $\\varphi ( \\theta )$ 为累积量函数。",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "不同子空间内重叠概率模型的条件概率可表示为",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\np \\big ( y | \\theta \\big ) = \\sum _ { b } \\frac { \\pi \\big ( b \\big ) } { c \\big ( b \\big ) } \\prod _ { l = 1 } ^ { L } p \\big ( y _ { i } | \\theta _ { l } \\big ) ^ { \\qquad b _ { l } }\n$$",
        "text_format": "latex",
        "page_idx": 2
    },
    {
        "type": "text",
        "text": "其中: $\\boldsymbol { b } = \\left[ b _ { 1 } , \\cdots , b _ { \\boldsymbol { L } } \\right]$ 为一组布尔向量(潜变量)，用于判断数据的重叠情况， $b _ { l } \\in \\{ 0 , 1 \\}$ ， $\\mathbf { b }$ 中每个元素均对应一个子空间。 $c ( b )$ 为归一化数。定义 $\\pi ( b )$ 为 $b$ 的先验，每个向量 $b$ 都对应着一个$\\pi ( b )$ ，若向量 $b$ 中所有元素均为零时，则令 $\\pi ( 0 ) = 0$ ，表明在数据集内会存在一些离值点，它们并不属于任何簇，但是这些值往往不能被忽略不计，由于其不属于重叠概率模型的结构，所以式(19)可以表示为",
        "page_idx": 2
    },
    {
        "type": "equation",
        "text": "$$\np \\left( y \\vert \\theta \\right) = \\left\\{ \\sum _ { b } \\frac { \\pi \\left( b \\right) } { c \\left( b \\right) } \\prod _ { l = 1 } ^ { L } p \\left( y _ { i } \\vert \\theta _ { l } \\right) ^ { b _ { l } } \\right. , \\qquad b \\neq 0\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "重叠概率模型的每个component都服从于同一指数族分布，则式(19)可被改写为",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\np \\left( { y } \\mid { \\theta } , { b } \\right) = \\frac { 1 } { { c } \\left( { b } \\right) } \\exp \\left\\{ \\sum _ { l = 1 } ^ { L } b _ { l } { \\theta } _ { l } T \\left( { y } \\right) - b _ { l } \\varphi \\left( { \\theta } _ { l } \\right) \\right\\}\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "直接计算得",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\nc \\big ( b \\big ) = \\exp \\left\\{ \\varphi \\Bigg ( \\sum _ { l = 1 } ^ { L } b _ { l } \\theta _ { l } \\Bigg ) - \\sum _ { l = 1 } ^ { L } b _ { l } \\varphi \\big ( \\theta _ { l } \\big ) \\right\\}\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "利用 $c ( b )$ 的闭合形式可以得到",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\np \\left( \\boldsymbol { y } \\mid \\boldsymbol { \\theta } , \\boldsymbol { b } \\right) = \\exp \\left\\{ T \\left( \\boldsymbol { y } \\right) \\sum _ { l = 1 } ^ { L } b _ { l } \\theta _ { l } - \\varphi \\Bigg ( \\sum _ { l = 1 } ^ { L } b _ { l } \\theta _ { l } \\Bigg ) \\right\\}\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "从上式可以看出条件概率 $p \\big ( \\boldsymbol { y } | \\boldsymbol { \\theta } , \\boldsymbol { b } \\big )$ 的每项 component 均服从自然参数为 $\\sum _ { l = 1 } ^ { L } b _ { l } \\theta _ { l }$ 的指数族分布。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "由于潜变量b是一组布尔向量， $\\pi ( b )$ 为 $\\boldsymbol { \\mathbf { b } }$ 的先验，其中每个元素服从伯努利分布Bernoulli $\\phi _ { l }$ ，而 $\\phi _ { l }$ 先验分布服从贝塔分布 $\\mathrm { B e t a } \\left\\{ \\alpha _ { l } , \\beta _ { l } \\right\\}$ 。将其代入式(21)中可以得到概率模型的联合分布为",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\np \\big ( y , b , \\phi \\vert \\alpha , \\beta , \\theta \\big ) =\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\n{ \\frac { 1 } { c ( b ) } } \\Biggl ( \\prod _ { l = 1 } ^ { L } p \\left( \\phi _ { l } \\mid \\alpha _ { l } , \\beta _ { l } \\right) p \\left( b _ { l } \\mid \\phi _ { l } \\right) \\Biggr ) \\times \\Biggl ( \\prod _ { l = 1 } ^ { L + 1 } p \\left( y \\mid \\theta _ { l } \\right) ^ { b _ { l } } \\Biggr )\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "重叠子空间聚类的目的是判断高维数据的不同子空间的数据簇是否存在重叠关系。通过将高维数据利用低维子空间线性表示，得到数据点较为相似且稠密的子空间，针对这些子空间使用重叠概率模型用于判断数据簇间的重叠问题。判断过程中需要对模型的参数进行估计，还要对每个数据 $y _ { i }$ 推断出潜在簇的赋值向量 $b$ 。对于每个数据点 $\\left( y _ { i } , b \\right)$ 是条件独立的，所以重叠概率模型可通过求解条件概率的最大化似然函数求得，需要通过对联合概率函数乘积取log并将其最大化，可表示为",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\nL \\left( b , \\alpha , \\beta , \\theta \\right) = \\sum _ { i = 1 } ^ { n } \\log p \\left( y _ { i } , b _ { l } \\mid \\alpha , \\beta , \\theta \\right)\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "根据式(24)可得到",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\n\\begin{array} { c } { { \\mathrm { m a x } \\displaystyle \\sum _ { i = 1 } ^ { n } \\log p \\left( y _ { i } , b _ { i } \\mid \\alpha , \\beta , \\theta \\right) = } } \\\\ { { { \\mathrm { m a x } \\displaystyle \\left[ \\sum _ { i = 1 } ^ { n } \\log p \\left( b _ { i } \\mid \\alpha , \\beta \\right) + \\sum _ { i = 1 } ^ { n } \\log p \\left( y _ { i } \\mid b _ { i } , \\theta \\right) \\right] = } } } \\\\ { { { \\mathrm { m a x } \\displaystyle \\left[ \\sum _ { i = 1 } ^ { n } \\sum _ { l = 1 } ^ { L } \\log \\left( \\int _ { \\varnothing _ { i , l } } p \\left( b _ { i , l } \\mid \\phi _ { i , l } \\right) p \\left( \\phi _ { i , l } \\mid \\alpha _ { l } , \\beta _ { l } \\right) d \\phi _ { i , l } \\right) \\right] + } } } \\\\ { { { \\mathrm { m a x } \\displaystyle \\left[ \\sum _ { i = 1 } ^ { n } \\left( \\sum _ { l = 1 } ^ { L + 1 } b _ { i , l } \\log p \\left( y _ { i } \\mid \\theta _ { l } \\right) - \\log c \\left( b _ { i } \\right) \\right) \\right] } } } \\end{array}\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "由上式可知，计算重叠数据的关键在于二值向量 $b$ 的选择以及参数 $\\alpha , \\beta , \\theta$ 的估计。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "2.3参数估计 ",
        "text_level": 1,
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "在参数估计部分使用交替最大化算法[18]对子空间重叠概率模型中的参数进行估计，其过程主要分为两个部分：布尔向量 $b$ 的选择和 $\\alpha , \\beta , \\theta$ 参数估计。在布尔向量选择部分，给定$\\alpha , \\beta , \\theta$ 的参数值，由于每个子空间的数据点定义了一组布尔向量 $b _ { i , l }$ ，利用 $b _ { i , l }$ 优化得到最大对数似然。在参数估计部分，给定布尔向量集 $b _ { i , l }$ 的参数值，利用参数 $\\alpha , \\beta , \\theta$ 的值来优化对数似然函数，具体过程如下：",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "1)布尔选择a)给定初始 $\\alpha , \\beta , \\theta$ 值；",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "b)对于任意数据点，令 $b _ { i , l _ { 0 } }$ 为初始赋值向量(简写为 $b _ { 0 }$ )，定义向量 $\\nu _ { \\scriptscriptstyle { l } }$ 为第 $l$ 个元素为1，其余元素为0的布尔向量，构成布尔集 $V = \\left\\{ \\nu _ { 1 } , \\cdots , \\nu _ { L } \\right\\}$ ：",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "c)将布尔向量的迭代计算亦分为 $l ( l = 1 , . . . , L ^ { \\cdot } $ 层，采用快速启发式迭代法[13]计算每层所选的布尔向量的最优解 $b _ { i , l }$ ：",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "d)利用模拟退火算法在选择布尔向量的过程中跳出局部极值；",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "对于每层得到布尔向量 $b _ { i , l }$ 设置一个初始温度参数 $T _ { 0 }$ ，则布尔向量可表示为 $b _ { i , l } ^ { T _ { 0 } }$ ，定义 $f _ { T } < 1$ 为乘性因子，用于保证在每次迭代中温度参数T均呈下降趋势，最大迭代次数 $J _ { \\circ }$ 在得到新的一层布尔值时需要进行迭代判断，将搜索产生的新的布尔值 $\\boldsymbol { b } _ { i , l } ^ { T ^ { * } }$ 与 $b _ { i , l } ^ { T _ { 0 } }$ 进行比较，若 $b _ { i , l } ^ { T ^ { * } } < b _ { i , l } ^ { T _ { 0 } }$ 或达到最大迭代次数时，该层迭代终止。选择每一层的最优布尔向量集 $b _ { { } _ { l } * }$ 。(本文参数取值：${ T _ { 0 } } = 5 0 , \\quad { f _ { T } } = 0 . 6 7 , \\ J = 4 0 ) _ { \\circ }$ ",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "当 $b _ { \\scriptscriptstyle { l ^ { * } } }$ 的值为1时，认为该样本数据属于其对应的子空间。若 $b _ { { \\scriptscriptstyle l } * } = 0$ 则认为该样本数据不属于对应的子空间。当一组布尔向量中有两个或两个以上元素的布尔值为1时，可以认为该样本数据为重叠数据，可属于多个子空间。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "$2 ) \\alpha , \\beta , \\theta$ 参数估计",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "a)参数 $\\alpha , \\beta$ 估计。给定布尔向量集 $b _ { i , l }$ ，令 $t _ { l }$ 表示 $b _ { i , l }$ 中1的个数，则 $n - t _ { l }$ 表示 $b _ { i , l }$ 中0的个数。最优贝塔分布参数满足下式：",
        "page_idx": 3
    },
    {
        "type": "equation",
        "text": "$$\n\\frac { \\alpha _ { l } } { \\beta _ { l } } = \\frac { t _ { l } } { n - t _ { l } }\n$$",
        "text_format": "latex",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "在本文实验中取 $\\beta _ { \\iota } = 1$ ，则 $\\alpha _ { \\iota } = t _ { \\iota } / \\left( n - t _ { \\iota } \\right)$ 。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "b)参数 $\\theta$ 估计。利用式(26)的对数似然函数第二部分计算最优极值 ${ \\boldsymbol { \\theta } } _ { l } ^ { * }$ 计算最优极值 ${ \\boldsymbol { \\theta } } _ { l } ^ { * }$ 的具体推导过程见附录1。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "2.4算法描述",
        "text_level": 1,
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "算法2 OSCSC",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "输入： 数据集 $X$ ，权衡系数 $\\lambda$ ，类数 $L$ ，初始温度 $T _ { 0 }$ 。  \n输出：聚类结果。",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "利用式(13)得到加权的 $l _ { 1 }$ 和Frobenius混合范数的子空间表示模型;",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "根据算法1优化得到 $z ^ { * }$ ，并得到求出相似矩阵$U = { \\frac { 1 } { 2 } } ( \\left| Z \\right| { + } \\left| Z ^ { \\mathrm { T } } \\right| ) ;$ ",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "使用一种标准分割方法Ncut对子空间进行分割并得到子",
        "page_idx": 3
    },
    {
        "type": "text",
        "text": "空间集合 $( S , Y )$ ·",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "对得到的 $( S , Y )$ 使用重叠概率模型得到其联合分布函数;  \n根据式(25)得到最大似然函数 $L ( b , \\alpha , \\beta , \\theta )$ 并估计参数。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "for 每次迭代",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "固定 $( \\alpha , \\beta , \\theta )$ ，优化 $b$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "固定 $b$ ，使用优化 $( \\alpha , \\beta , \\theta )$ 。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "对于每层选取的布尔向量利用模拟退火算法搜索最优解，即得到最终的布尔向量值 $b _ { l ^ { * } }$ ，并根据 $b _ { t * }$ 判断重叠情况。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "3 实验结果与分析",
        "text_level": 1,
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "为了验证OSCSC算法的有效性，实验选取5种聚类算法与本文算法进行对比，并在人造数据集以及真实基准数据集测试算法性能。5种对比算法分别为SSC，LSR，RSSC，MOC和BOSC。本文在MATLABR2016a 编程环境下实现。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "实验采用聚类准确率AC(accuracy)[19-20]、标准化互信息NMI(normalized mutual information)[21]以及运行时间作为评价准则用于评价OSCSC 算法性能。为了提高算法的可靠性，将实验中的6种算法独立运行10次，AC计算公式为",
        "page_idx": 4
    },
    {
        "type": "equation",
        "text": "$$\n\\ A C = { \\frac { \\displaystyle \\sum _ { i = 1 } ^ { N } \\delta { \\big ( } s _ { i } , m a p { \\big ( } r _ { i } { \\big ) } { \\big ) } } { N } }\n$$",
        "text_format": "latex",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "其中: $N$ 为样本总数， $\\delta ( \\mathbf { \\theta } )$ 函数表示的意义为：当函数内两个参数相等时，函数值为1，否则为 $0 \\circ \\textit { s } _ { i }$ 为样本数据原始类别，$r _ { i }$ 为聚类后样本数据的类别， $m a p \\big ( r _ { i } \\big )$ 为映射函数，将聚类后的类别映射为与样本原始类别等价的类别。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "NMI的计算公式为",
        "page_idx": 4
    },
    {
        "type": "equation",
        "text": "$$\nN M I = \\frac { \\displaystyle \\sum _ { i = 1 } ^ { c } \\sum _ { j = 1 } ^ { c } n _ { i j } \\ln \\frac { N n _ { i j } } { n _ { i } n _ { j } } } { \\sqrt { \\left( \\displaystyle \\sum _ { i = 1 } ^ { c } n _ { i } \\ln \\frac { n _ { i } } { N } \\right) \\left( \\displaystyle \\sum _ { j = 1 } ^ { c } n _ { j } \\ln \\frac { n _ { j } } { N } \\right) } }\n$$",
        "text_format": "latex",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "其中: $N$ 为样本总数， $\\vert c \\vert$ 为类簇数， $n _ { i }$ 和 $n _ { j }$ 分别表示为属于类簇$i$ 和类簇 $j$ 的样本数， $n _ { i j }$ 为属于类簇 $i$ 和类簇 $j$ 的相同样本的个数。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "3.1人造数据集实验结果",
        "text_level": 1,
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "为了测试算法性能，本节实验采用文献[22]的方法随机生成两个人造数据集dataset1和dataset2。人造数据集dataset1中包含500个数据样本，类数为4，维度为30。人造数据集dataset2中包含3000个数据样本，类数为6，维度为80。为了更加接近真实数据集，在人造数据集中定义不同类之间存在一定的重叠样本，用于测试算法发现重叠簇的能力。人造数据集dataset1和dataset2的基本信息如表1所示。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "本文使用权衡系数平衡 $l _ { 1 }$ 范数和Frobenius 范数之间的关系，通过改变的值使得聚类效果最佳。在2个人造数据集上λ与算法聚类准确率间的关系如图1所示，根据图1可知当λ分别取0.8和0.85时使得算法聚类准确率最佳。实验将OSCSC 算法与其他5种算法分别在两个人造数据集上进行测试。6种算法在dataset1上的实验结果见表2。6种算法在dataset2上的实验结果见表3。",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 4
    },
    {
        "type": "table",
        "img_path": "images/c951cf26e1725cb87e0596adf8db6faa50536d74a19fbf8da4de3787ac2fccb5.jpg",
        "table_caption": [
            "表1人造数据集信息"
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td>数据集</td><td>类别</td><td>样本数</td><td>维度</td></tr><tr><td rowspan=\"5\">dataset1</td><td>1</td><td>62</td><td>30</td></tr><tr><td>2</td><td>207</td><td>30</td></tr><tr><td>3</td><td>136</td><td>30</td></tr><tr><td>4</td><td>95</td><td>30</td></tr><tr><td>1</td><td>253</td><td>80</td></tr><tr><td rowspan=\"5\">dataset2</td><td>2</td><td>657</td><td>80</td></tr><tr><td>3</td><td>510</td><td>80</td></tr><tr><td>4</td><td>649</td><td>80</td></tr><tr><td>5</td><td>389</td><td>80</td></tr><tr><td>6</td><td>542</td><td>80</td></tr></table></body></html>",
        "page_idx": 4
    },
    {
        "type": "image",
        "img_path": "images/1e1b1a040347960f65029e2c5238904493d3e1893e769c51a9673d8c43260d51.jpg",
        "img_caption": [
            "图1权衡系数与聚类准确率的关系"
        ],
        "img_footnote": [],
        "page_idx": 4
    },
    {
        "type": "table",
        "img_path": "images/edacbb4d8b482032bb863b46ac2158114b3d08d7df7841eb203de02fcd119296.jpg",
        "table_caption": [
            "表26种算法在dataset1上的实验结果对比 $( \\% )$ "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td colspan=\"2\"></td><td>SSC</td><td>RSSC</td><td>LSR</td><td>MOC</td><td>BOSC</td><td>OSCSC</td></tr><tr><td rowspan=\"2\">AC</td><td>均值</td><td>68.83</td><td>72.53</td><td>71.37</td><td>68.55</td><td>72.91</td><td>76.43</td></tr><tr><td>标准差</td><td>1.003</td><td>0.885</td><td>0.542</td><td>1.126</td><td>0.937</td><td>0.953</td></tr><tr><td rowspan=\"2\">NMI</td><td>均值</td><td>69.54</td><td>70.56</td><td>70.87</td><td>69.47</td><td>74.29</td><td>77.52</td></tr><tr><td>标准差</td><td>0.857</td><td>0.962</td><td>1.233</td><td>0.779</td><td>1.025</td><td>0.874</td></tr><tr><td>运行时间/s</td><td>均值</td><td>5.16</td><td>6.42</td><td>1.13</td><td>10.63</td><td>8.74</td><td>7.51</td></tr></table></body></html>",
        "page_idx": 4
    },
    {
        "type": "table",
        "img_path": "images/ebe074836bb43451a60aba6fe14ad8c3b93ee1894c1ed1df97810840b7d1a888.jpg",
        "table_caption": [
            "表36种算法在dataset2上的实验结果对比 $( \\% )$ "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td></td><td></td><td>SSC</td><td>RSSC LSR</td></tr><tr><td>AC</td><td>62.87</td><td>65.53 64.74</td><td>MOC BOSC 64.23 68.96</td></tr><tr><td></td><td>均值</td><td></td><td>70.35 1.125</td></tr><tr><td>标准差</td><td>1.705 1.139</td></tr><tr><td>1.224 0.721 1.337</td><td></td></tr><tr><td></td><td></td></tr><tr><td>均值 64.05 64.81 标准差</td><td>62.57 66.42 68.32</td></tr><tr><td>1.418 1.059</td><td>72.14</td></tr><tr><td>1.263 0.931</td><td>1.163 0.985</td></tr><tr><td>NMI</td><td></td></tr><tr><td>运行时间/s 均值 54.93 60.19</td><td></td></tr><tr><td>13.89</td><td>92.57 77.83 74.22</td></tr><tr><td></td><td></td></tr></table></body></html>",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "根据dataset1和dataset2数据集上的实验结果可知MOC、",
        "page_idx": 4
    },
    {
        "type": "text",
        "text": "BOSC和OSCSC算法的聚类准确率要优于SSC、LSR、RSSC等基于硬划分的聚类方法，但MOC和BOSC算法在处理样本数较大、数据分布稀疏且具有一定维度的数据集时，不能充分利用数据空间信息，导致算法运行速率较差。本文算法利用加权的混合范数子空间表示方法将高维数据空间划分为若干低维子空间集合，从一定程度上减少了对样本数据集直接进行重叠聚类的难度，能够较好地处理具有一定规模和一定维度的数据集。根据表2和3的结果可以看出本文算法在两种规模不同的人造数据集上均取得了较为理想的聚类性能。通过对比6种聚类算法的平均运行时间可知，其中LSR 算法运行效率较高，OSCSC算法由于在判断重叠数据时采用概率模型并使用模拟退火的方法使该模型尽可能收敛于全局最优解，保证聚类的准确性，这样会增加算法的运行时间，但MOC和BOSC算法相比较而言，本文算法的运行时间较为理想。",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "为了进一步验证OSCSC 算法处理噪声数据的有效性，实验在两个人造数据集上加入不同比例的噪声干扰(受干扰的数据位置随机选定)，分别测试6种算法的聚类准确率。噪声干扰比例依次设置为 $10 \\%$ 、 $20 \\%$ 、 $30 \\%$ 、 $40 \\%$ 和 $50 \\%$ ，实验结果见表4。根据表4的实验结果可以看出，本文算法能够处理不同程度的噪声数据集并且与其他算法相比当噪声干扰程度的增大时OSCSC算法的聚类准确率变化不大，受噪声影响较小。",
        "page_idx": 5
    },
    {
        "type": "table",
        "img_path": "images/8c777376c7373d3aea38bcb0ad251649ab4a478e8a5f17e6ccb2633bf86ab791.jpg",
        "table_caption": [],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td>数据集</td><td>噪声干扰比例</td><td>SSC</td><td>RSSC</td><td>LSR</td><td>MOC</td><td>BOSC</td><td>OSCSC</td></tr><tr><td rowspan=\"5\">databasel</td><td>10%</td><td>68.72</td><td>72.27</td><td>70.82</td><td>67.73</td><td>72.17</td><td>75.86</td></tr><tr><td>20%</td><td>68.07</td><td>71.39</td><td>69.41</td><td>67.19</td><td>70.93</td><td>75.43</td></tr><tr><td>30%</td><td>66.56</td><td>70.83</td><td>68.27</td><td>66.01</td><td>69.54</td><td>74.22</td></tr><tr><td>40%</td><td>63.38</td><td>68.34</td><td>65.97</td><td>64.75</td><td>68.31</td><td>73.59</td></tr><tr><td>50%</td><td>60.88</td><td>65.36</td><td>62.71</td><td>61.78</td><td>65.82</td><td>72.46</td></tr><tr><td rowspan=\"5\">database2</td><td>10%</td><td>62.13</td><td>64.86</td><td>64.25</td><td>63.71</td><td>68.45</td><td>70.24</td></tr><tr><td>20%</td><td>61.49</td><td>64.31</td><td>63.58</td><td>63.08</td><td>67.62</td><td>69.43</td></tr><tr><td>30%</td><td>60.37</td><td>62.94</td><td>62.46</td><td>62.72</td><td>66.23</td><td>68.55</td></tr><tr><td>40%</td><td>58.63</td><td>60.44</td><td>61.09</td><td>61.28</td><td>64.84</td><td>67.23</td></tr><tr><td>50%</td><td>55.89</td><td>57.64</td><td>59.83</td><td>59.29</td><td>63.15</td><td>65.61</td></tr></table></body></html>",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "3.2真实数据集实验结果",
        "text_level": 1,
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "本节实验采用国际通用的六个真实数据集测试算法性能。真实数据集基本信息如表5所示。其中，musk、soybean、waveform 和 pendigits 均为UCI 数据集(http://archive.ics.uci.edu/ml/datasets.html)。USPS 为手写数字数据集(http://www.cs.nyu.edu/\\~roweis/data.html)，包含0\\~9共10 种类型的数字图像，每幅图片大小为 $1 6 \\times 1 6$ ，由一个256维的特征向量表示，本文从每个类中随机选取100 幅图像(共 1000 幅图像)用于测试。AR 数据集(http://www2.ece.ohio-state.edu/\\~aleix/ARdatabase.html)包含了126人超过4000幅人脸图像，本文随机选取其中80人共960 幅图像进行测试，利用降采样方式将每幅图像大小将至 $3 2 \\times 2 4$ 。",
        "page_idx": 5
    },
    {
        "type": "table",
        "img_path": "images/dcea41e07a07d1f4e325c2086978b800b1ec70184535a33b43074f0f1d9861e5.jpg",
        "table_caption": [
            "表5真实数据集基本信息"
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td>数据集</td><td>类数</td><td>样本数</td><td>维度</td></tr><tr><td>musk</td><td>2</td><td>476</td><td>168</td></tr><tr><td>soybean</td><td>19</td><td>307</td><td>35</td></tr><tr><td>waveform</td><td>3</td><td>5000</td><td>21</td></tr><tr><td>pendigits</td><td>10</td><td>10992</td><td>16</td></tr><tr><td>AR</td><td>80</td><td>960</td><td>768</td></tr><tr><td>USPS</td><td>10</td><td>1000</td><td>256</td></tr></table></body></html>",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "由于λ主要用于平衡两个正则项之间的关系，其取值会直接影响算法的聚类结果。故本节实验给出OSCSC 算法在6个真实数据集上权衡系数λ与算法聚类准确率间的关系，如图2所示。由图2可知，在musk数据集上当权衡系数 $\\lambda = 0 . 7 5$ 时，能够得到最佳聚类结果，依次地，在 soybean、waveform、pendigits、AR和USPS数据集上λ分别取0.95、0.85、0.8、0.7和0.8时本文算法可以获得最佳聚类结果。",
        "page_idx": 5
    },
    {
        "type": "text",
        "text": "将6种算法在六个真实数据集上进行测试，其AC和NMI的实验结果分别见表6、7。根据表6和7的实验结果可知，OSCSC算法在6个真实数据集上均能够取得较为理想的聚类结果。SSC、LSR、RSSC算法均为基于硬划分的聚类方法，当在聚类过程中发生错误时无法及时校验，导致数据无法归于正确的类中。MOC、BOSC和OSCSC算法均属于软划分方法，允许数据属于多个类别。但是MOC和BOSC在处理一定数据规模维数数据集时聚类效果不够理想。OSCSC算法利用加权的混合范数的子空间表示方法将其分割为若干子空间，并对子空间内的数据进行聚类分析，在保证同一子空间数据的稠密性和不同子空间数据的稀疏性，尽可能将数据划分到正确子空间内。其次对得到的结果使用重叠概率模型进行二次校验，避免了在整个高维空间内直接对数据进行一一匹配，利用重叠概率模型能够有效地发现数据集内的重叠样本，将错误分配的数据归到正确的子空间中，提高了聚类的准确率。通过表6和7的每个算法结果的标准差可知，本文算法每次运行所得到的结果较为稳定。",
        "page_idx": 5
    },
    {
        "type": "table",
        "img_path": "images/26e9caa63e763881cf270eebb0dafcc5d23d4f87dbafab7e85abd27082898fc1.jpg",
        "table_caption": [
            "表4不同噪声程度下6种算法的聚类准确率 $1 \\%$ ",
            "表6六种算法在真实数据集上的AC 实验结果 $( \\% )$ "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td colspan=\"4\">musk soybean waveform pendigits AR USPS</td></tr><tr><td rowspan=\"2\">SSC</td><td>均值 67.57 69.87</td><td>60.26</td><td>55.86 70.23 52.53</td></tr><tr><td>标准差0.824 1.197</td><td>0.735</td><td>1.434 0.768 1.005</td></tr><tr><td rowspan=\"2\">RSSC</td><td>均值 70.37 71.54</td><td>59.87</td><td>56.93 71.52 61.67</td></tr><tr><td>标准差1.025 0.984</td><td>0.723</td><td>1.174 0.692 1.325</td></tr><tr><td rowspan=\"2\">LSR</td><td>均值 71.51 68.11</td><td>62.72</td><td>59.43 73.68 68.71</td></tr><tr><td>标准差0.779 1.265</td><td>0.952</td><td>1.085 0.8431.146</td></tr><tr><td rowspan=\"2\">MOC</td><td>均值 72.32 72.71</td><td>65,22</td><td>79.28 72.41 66.43</td></tr><tr><td>标准差2.311 1.485</td><td>1.241</td><td>1.486 2.013 1.341</td></tr><tr><td rowspan=\"2\">BOSC</td><td>均值 71.85 74.93</td><td>70.83</td><td>86.78 74.65 68.43</td></tr><tr><td>标准差0.966 0.789</td><td>0.951</td><td>0.737 0.971 0.743</td></tr><tr><td rowspan=\"2\">OSCSC</td><td>均值 70.34 78.13</td><td>70.55</td><td>92.86 80.37 74.28</td></tr><tr><td>标准差0.836 1.147</td><td>0.972</td><td>1.336 0.624 0.858</td></tr></table></body></html>",
        "page_idx": 5
    },
    {
        "type": "image",
        "img_path": "images/b3fbde9602dfbcb63db82e89e280134c66771a9797b2d400fd1109a42b21f77d.jpg",
        "img_caption": [
            "图2权衡系数与聚类准确率的关系"
        ],
        "img_footnote": [],
        "page_idx": 6
    },
    {
        "type": "table",
        "img_path": "images/9aa96dc4e76de19c5ae680589ad62861bed9e27f82697f2425904df5daabb30e.jpg",
        "table_caption": [
            "表76种算法在真实数据集上的NMI实验结果 $( \\% )$ "
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td></td><td>musk soybean waveform pendigits</td><td></td><td></td><td></td><td>AR USPS</td></tr><tr><td rowspan=\"2\">SSC</td><td>均值 58.68</td><td>60.41</td><td>53.47</td><td>50.18</td><td>64.42 53.85</td></tr><tr><td>标准差0.877</td><td>0.932</td><td>1.072</td><td>1.257</td><td>1.147 0.536</td></tr><tr><td rowspan=\"2\">RSSC</td><td>均值 60.32</td><td>62.54</td><td>51.61</td><td>50.75</td><td>67.87 58.13</td></tr><tr><td>标准差1.042</td><td>0.848</td><td>1.105</td><td>0.836</td><td>0.773 0.834</td></tr><tr><td rowspan=\"2\">LSR</td><td>均值 65.31</td><td>59.98</td><td>54.06</td><td>52.93</td><td>74.35 65.72</td></tr><tr><td>标准差0.948</td><td>0.964</td><td>0.937</td><td>1.375</td><td>0.887 0.641</td></tr><tr><td rowspan=\"2\">MOC</td><td>均值 64.81</td><td>65.12</td><td>58.48</td><td>73.44</td><td>74.91 63.48</td></tr><tr><td>标准差1.258</td><td>0.924</td><td>1.263</td><td>1.575</td><td>1.429 1.126</td></tr><tr><td rowspan=\"2\">BOSC</td><td>均值 64.13</td><td>70.29</td><td>60.62</td><td>79.94</td><td>73.83 67.28</td></tr><tr><td>标准差1.041</td><td>1.289</td><td>1.432</td><td>1.623</td><td>1.388 1.245</td></tr><tr><td rowspan=\"2\">OSCSC</td><td>均值 64.24</td><td>73.87</td><td>61.29</td><td>86.31</td><td>78.24 72.93</td></tr><tr><td>标准差0.931</td><td>1.157</td><td>0.947</td><td>1.321</td><td>0.863 0.679</td></tr></table></body></html>",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "六种算法在真实数据集上的平均运行时间如表8所示。根据表8可知LSR算法的运行时间最短，OSCSC算法在处理规模较大的数据集时算法的运行速率要优于与MOC和BOSC算法，这是由于本文算法在对数据样本进行重叠判断之前，充分利用高维数据的低维子空间表示结构进行子空间划分，并针对这些划分好的子空间内数据进行重叠判断，而没有从整个数据空间直接进行重叠聚类，降低了直接处理高维数据的难度，算法的运行效率与其他重叠聚类算法相比较为理想。与SSC 和RSSC相比，根据不同数据集的特性而言，如果数据集本身存在重叠数据较多，本文利用重叠概率模型判断数据重叠时所时间较长，运行效率要低于SSC、RSSC算法。OSCSC算法在对pendigits数据集进行聚类时所用时间较长，其原因是该数据集内数据的重叠情况较多，算法利用重叠概率模型处理重叠问题时将这些重叠数据分配到对应的不同子空间的过程会消耗较多的时间。其次由于 soybean 数据集和 AR 数据集内包含的类别数较多，在计算数据重叠情况时，算法需要判断的类别数较多，增加了算法的聚类时间，可见采用软划分技术的聚类算法在处理类别数较多的数据集时时间消耗过多。但综合表6和7的实验结果，本文算法的整体聚类性能要优于其他五种聚类算法。",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "4 结束语",
        "text_level": 1,
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "本文提出的OSCSC算法采用加权的 $l _ { 1 }$ 范数和Frobenius范数的混合范数表示方法建立子空间模型，将高维数据通过低维子空间线性表示，提高了同一子空间数据的稠密性和不同子空间数据的稀疏性。对已划分的子空间使用重叠概率模型判断子空间内数据的重叠情况，并通过交替最大化算法对模型进行参数估计，在参数估计过程中使用模拟退火的方法寻求模型的最优解，进一步将数据归于正确子空间内，提高了聚类准确率。在不同规模的人造数据集和真实数据集上的测试结果表明，OSCSC算法能够获得较为理想的聚类结果。下一步的工作将重点研究如何提高重叠子空间算法的运行效率。",
        "page_idx": 6
    },
    {
        "type": "text",
        "text": "",
        "page_idx": 7
    },
    {
        "type": "table",
        "img_path": "images/ef9501b24dee5b732056753ae961c9c1d2b08f6eff3d087fb6f57d6296e80878.jpg",
        "table_caption": [
            "表8六种算法在真实数据集上的平均运行时间 /:"
        ],
        "table_footnote": [],
        "table_body": "<html><body><table><tr><td></td><td>musk</td><td>soybean</td><td>waveform pendigits</td><td></td><td>AR</td><td>USPS</td></tr><tr><td>SSC</td><td>7.21</td><td>8.34</td><td>108.22</td><td>191.25</td><td>20.83</td><td>16.54</td></tr><tr><td>LSR</td><td>2.24</td><td>3.07</td><td>36.71</td><td>55.67</td><td>4.23</td><td>3.32</td></tr><tr><td>RSSC</td><td>9.68</td><td>11.52</td><td>110.57</td><td>207.31</td><td>28.56</td><td>21.75</td></tr><tr><td>MOC</td><td>24.55</td><td>45.31</td><td>146.18</td><td>294.47</td><td>68.93</td><td>63.31</td></tr><tr><td>BOSC</td><td>10.73</td><td>35.63</td><td>93.58</td><td>273.67</td><td>52.49</td><td>53.87</td></tr><tr><td>OSCSC</td><td>9.26</td><td>33.81</td><td>115.34</td><td>269.36</td><td>47.32</td><td>45.06</td></tr></table></body></html>",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "参考文献：",
        "text_level": 1,
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "[1]Elhamifar E,Vidal R.Sparsity in unions of subspaces for classification and clustering of high-dimensional data [C]//Proc of the 49th Annual Allerton Conference on Communication, Control,and Computing.2011:1085-1089.   \n[2]Peng X,Tang HJ,Zhang L,et al.A unified framework for representationbased subspace clustering of out-of-sample and large-scale Data [J]. IEEE Trans on Neural Networks and Learning Systems,2016,27(12): 2499-2512.   \n[3]陈爱国，王士同．基于多代表点的大规模数据模糊聚类算法[J].控制 与决策,2016,31(12):2122-2130.   \n[4]Hu H, Lin Z C,Feng JJ,et al. Smooth representation clustering [C]// Proc of IEEE International Conference on Computer Vision and Pattern Recognition. 2014: 3834-3841.   \n[5]Agrawal R, Geherke J, Gunopulos D. et al.Automatic subspace clustering of high dimensional data [J].Data Mining and Knowledge Discovering, 2005,11 (1): 5-33.   \n[6]王卫卫，李小平，冯象初，等．稀疏子空间聚类综述[J]．自动化学报, 2015,41 (8): 1373-1384.   \n[7]Elhamifar E, Vidal R.Sparse subspace clustering: algorithm,theory,and applications [J].IEEE Trans on Pattern Analysis and Machine Intelligence, 2013,35 (11): 2765-2781.   \n[8]Lu C Y,Min H, Zhao Z Q,et al. Robust and efficient subspace segmentation via least squares regression [Cl//Proc of the 12th European Conference on Computer Vision.2012: 347-360.   \n[9] Liu G C,Lin Z C,Yu Y. Robust subspace segmentation by low-rank representation [C]// Proc of the 27th International Conference on Machine Leaning.2010: 663-670.   \n[10] Xu J,Xu K,Chen K,et al.Reweighted sparse subspace clustering [J]. Computer Vision and Image Understanding,2015 138:25-37. ",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "[11]张涛，唐振民，吕建勇．一种基于低秩表示的子空间聚类改进算法[J].",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "电子与信息学报,2016,38(11):2811-2818.   \n[12] Baadel S,Thabtah F,LU J. Overlapping clustering: a review [C]/ Proc of IEEE Conference on SAI Computing. 2016: 233-237.   \n[13] Banerjee A,Krumpelman C,Ghosh J,et al. Model-based overlapping clustering [Cl//Proc ofthe 11th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining.2005:532-537.   \n[14] Fu Q, Banerjee A. Bayesian overlapping subspace clustering [C]// Proc of IEEE International Conference on Data Mining.2009:776-781.   \n[15] Candes EJ,Wakin MB,Boyd SP.Enhancing sparsity by reweighted l1 Minimization [J]. Journal ofFourier Analysis and Applications,2008,14 (5): 877-905.   \n[16] Panagakis Y,Kotropoulos C.Elastic net clustering applied to pop//rock music structure analysis [J]. Pattern Recognition Leters,2014,38 (3): 46- 53.   \n[17] Shi JB,Malik J.Normalized cuts and image segmentation [J].IEEE Trans on Pattern Analysis and Machine Intelligence,20oo,22 (8): 888-905.   \n[18] Fu Q,Multiplication mixture models for overlapping clustering [C]//Proc ofIEEE International Conference on Data Mining.20o8:791-796.   \n[19]刘展杰，陈晓云．局部子空间聚类[J]．自动化学报,2016,42(8):1238- 1247.   \n[20] Cai D,He XF,Han JW.Non-negative matrix factorization on manifold [C]// Proc of the 8th IEEE International Conference on Data Mining.2008:63- 72.   \n[21]邓赵红，张丹丹，蒋亦樟．基于划分自适应融合的多视角模糊聚类算法 [J].控制与决策,2016,31(4):593-600.   \n[22] Aggarwal C C,Procopiuc C M,WolfJL,et al.Fast algorithms for projected clustering [C]/ Proc of ACM SIGKDD International Conference on Management of Data. New York: ACM Press,1999: 61-72. ",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "附录最优极值 ${ \\boldsymbol { \\theta } } _ { l } ^ { * }$ 的计算",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "利用式(26)的对数似然函数第二部分完成参数 $\\theta$ 值的估计，即",
        "page_idx": 7
    },
    {
        "type": "equation",
        "text": "$$\nf \\left( \\theta \\right) { = } { \\sum _ { i = 1 } ^ { n } } { \\left( \\sum _ { l = 1 } ^ { L + 1 } { b _ { i , l } } \\log { p \\left( { y _ { i } \\mid \\theta _ { l } } \\right) } { - \\log { c \\left( { b _ { i } } \\right) } } \\right) }\n$$",
        "text_format": "latex",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "将式(18)代入上式可得 ",
        "page_idx": 7
    },
    {
        "type": "equation",
        "text": "$$\nf \\left( \\theta \\right) = \\sum _ { i = 1 } ^ { n } \\left( T \\Big ( y \\Big ) \\sum _ { l = 1 } ^ { L + 1 } b _ { i , l } \\theta _ { l } - \\varphi \\Bigg ( \\sum _ { l = 1 } ^ { L + 1 } b _ { i , l } \\theta _ { l } \\Bigg ) \\right)\n$$",
        "text_format": "latex",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "将上式对 $\\theta _ { \\iota }$ 求二阶导数，可得",
        "page_idx": 7
    },
    {
        "type": "equation",
        "text": "$$\n\\nabla _ { \\theta _ { j } } ^ { 2 } f ( \\theta ) = - \\underset { i = 1 } { \\overset { n } { \\sum } } b _ { i , 1 } \\nabla _ { \\theta _ { l } } ^ { 2 } \\varphi \\Bigg ( \\underset { l = 1 } { \\overset { L + 1 } { \\sum } } b _ { i , l } \\theta _ { l } \\Bigg )\n$$",
        "text_format": "latex",
        "page_idx": 7
    },
    {
        "type": "text",
        "text": "由于 $\\varphi ( \\theta )$ 为累积量函数，其值为正数，所以得到的 $\\nabla _ { \\theta _ { l } } ^ { 2 } f \\mathopen { } \\mathclose \\bgroup \\left( \\theta \\aftergroup \\egroup \\right)$ 为负，$f ( \\theta )$ 表现为凸函数。由此可将 $f ( \\theta )$ 对 $\\theta _ { \\iota }$ 求一阶导数，使其为 $0$ ，计算最优极值 ${ \\boldsymbol { \\theta } } _ { l } ^ { * }$ ，其最优极值为",
        "page_idx": 7
    },
    {
        "type": "equation",
        "text": "$$\n\\theta _ { l } ^ { * } = - \\sum _ { i = 1 ; b _ { i , l } = 1 } ^ { n } \\sum _ { w = 1 } ^ { L + 1 } b _ { i , \\mathrm { w } } \\theta _ { w } + \\nabla _ { \\theta _ { l } } ^ { - 1 } \\varphi \\left( \\sum _ { i = 1 ; b _ { i , l } = 1 } ^ { n } T ( y ) \\right)\n$$",
        "text_format": "latex",
        "page_idx": 7
    }
]